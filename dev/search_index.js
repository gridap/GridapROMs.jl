var documenterSearchIndex = {"docs":
[{"location":"steady/#Usage-Steady-problem","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"","category":"section"},{"location":"steady/#Installation","page":"Usage - Steady problem","title":"Installation","text":"GridapROMs is a registered package. You can install it by running:\n\n# Use ] to enter the Pkg REPL mode\npkg> add GridapROMs","category":"section"},{"location":"steady/#Load-package","page":"Usage - Steady problem","title":"Load package","text":"Load the package normally with\n\nusing GridapROMs","category":"section"},{"location":"steady/#Workflow","page":"Usage - Steady problem","title":"Workflow","text":"The workflow of the package is analogous to that of Gridap, a library for the grid-based approximation of PDEs. Comprehensive Gridap tutorials can be found here. We load Gridap with \n\nusing Gridap","category":"section"},{"location":"steady/#Manufactured-solution","page":"Usage - Steady problem","title":"Manufactured solution","text":"In this example we solve a parameter dependent Poisson equation \n\nleft\nbeginarrayrcll\n-nu Delta u = f  textin  Omega  \nnu nabla u cdot n = h  texton  Gamma_n \nendarray\nright\n\nwhere Ω is a sufficiently regular spatial domain, ν is a (positive) conductivity coefficient, u is the problem's unknown, f is a forcing term, and h a Neumann datum defined on the Neumann boundary Γ_n. In this problem, we consider Ω = 01^2 and Γ_n to be the right leg of the square. The remaining boundary is Dirichlet, and here we impose a manufactured, parameter-dependent solution. We consider the problem given by the following data: \n\nν(μ) = x -> exp(-μ[1]*x[1])\nu(μ) = x -> μ[1]*x[1] + μ[2]*x[2]\nf(μ) = x -> -ν(μ)(x)*Δ(u(μ))(x)\nh(μ) = x -> 1\n\nNext, we parameterize the data defined above exclusively by μ in the following manner:\n\nνₚ(μ) = parameterize(ν,μ)\nuₚ(μ) = parameterize(u,μ)\nfₚ(μ) = parameterize(f,μ)\nhₚ(μ) = parameterize(h,μ)\n\nA ParamFunction is a function that can be evaluated efficiently for any number of desired parameters. In a steady setting, it takes as argument a function (u, f and h in the cases above) and a parameter variable. In a transient setting, an additional time variable must be included (more details can be found in the following tutorial for transient problems).","category":"section"},{"location":"steady/#Geometry","page":"Usage - Steady problem","title":"Geometry","text":"We define the geometry of the problem using \n\nΩ = (0,1,0,1)\npartition = (10,10)\nΩₕ = CartesianDiscreteModel(Ω,partition)","category":"section"},{"location":"steady/#FE-spaces","page":"Usage - Steady problem","title":"FE spaces","text":"Once the discrete geometry is introduced, we define a tuple of trial, test spaces (UV) as\n\norder = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(Ωₕ,reffe;dirichlet_tags=[1,3,5,6,7])\nU = ParamTrialFESpace(V,uₚ)\n\nA ParamTrialFESpace extends a traditional TrialFESpace in Gridap, as it allows to provide a μ-dependent Dirichlet datum. The tags provided occupy the left, upper and bottom legs of the square (extrema excluded for the upper and bottom legs).","category":"section"},{"location":"steady/#Space-of-parameters","page":"Usage - Steady problem","title":"Space of parameters","text":"We define a space of parameters, in this case 110^2:\n\nD = ParamSpace((1,10,1,10))\n\nA parameter, in our case a 2-dimensional vector, is a single realization from D. By default, a parameter is sampled according to a Halton sequence. Other sampling methods can be defined by providing appropriate keyword arguments: \n\nParamSpace((1,10,1,10),sampling=:latin_hypercube)\nParamSpace((1,10,1,10),sampling=:normal)\nParamSpace((1,10,1,10),sampling=:uniform)\nParamSpace((1,10,1,10),sampling=:uniform_tensorial)\n\nA single parameter is sampled from D by calling\n\nμ = realization(D) \n\nwhereas a collection of 10 realizations can be obtained by running\n\nrealization(D;nparams=10)","category":"section"},{"location":"steady/#Numerical-integration","page":"Usage - Steady problem","title":"Numerical integration","text":"Before introducing the weak formulation of the problem, we define the quantities needed for the numerical integration \n\ndegree = 2*order\nτₕ = Triangulation(Ωₕ)\nΓₕ = BoundaryTriangulation(Ωₕ;tags=[2,4,8])\ndΩₕ = Measure(τₕ,degree)\ndΓₕ = Measure(Γₕ,degree)\n\nThe physical entities corresponding to the tags provided when defining Γₕ are: the bottom right vertex (2), the top right vertex (4) and the interior of the right edge (8).","category":"section"},{"location":"steady/#Weak-formulation","page":"Usage - Steady problem","title":"Weak formulation","text":"Multiplying the Poisson equation by a test function v  V and integrating by parts yields the weak formulation of the problem, whose left- and right-hand (LHS & RHS) side are\n\na(μ,u,v,dΩₕ) = ∫(νₚ(μ)*∇(v)⋅∇(u))dΩₕ \nl(μ,u,v,dΩₕ,dΓₕ) = a(μ,u,v,dΩₕ) - ∫(fₚ(μ)*v)dΩₕ - ∫(hₚ(μ)*v)dΓₕ\n\nNote that, in contrast to a traditional Gridap code, the measures involved in the forms are passed as arguments to the forms themselves. (This prevents us from defining a FE operator just by defining a bilinear form for the LHS and a linear form for the RHS as in Gridap: we must actually write the full expression of the residual). ","category":"section"},{"location":"steady/#Parametric-FE-problem","page":"Usage - Steady problem","title":"Parametric FE problem","text":"At this point, we can build a FE operator representing the Poisson equation: \n\nτₕ_l = (τₕ,Γₕ)\nτₕ_a = (τₕ,)\ndomains = FEDomains(τₕ_l,τₕ_a)\nfeop = LinearParamOperator(l,a,D,U,V,domains)\n\nThe structure FEDomains collects the triangulations relative to the LHS & RHS. With respect to a traditional FE operator in Gridap, a LinearParamOperator provides the aforementioned FEDomains for the LHS & RHS, as well as the parametric domain D.","category":"section"},{"location":"steady/#FE-solver","page":"Usage - Steady problem","title":"FE solver","text":"We define the FE solver for our Poisson problem: \n\nsolver = LUSolver()","category":"section"},{"location":"steady/#RB-solver","page":"Usage - Steady problem","title":"RB solver","text":"Finally, we are ready to begin the GridapROMs part. The first part consists in defining the problem's RBSolver, i.e. the reduced counterpart of a FE solver:\n\ntol = 1e-4\ninner_prod(u,v) = ∫(∇(v)⋅∇(u))dΩₕ\n\nreduction_sol = PODReduction(tol,inner_prod;nparams=20)\nreduction_l = MDEIMHyperReduction(tol;nparams=10)\nreduction_a = MDEIMHyperReduction(tol;nparams=10)\nrbsolver = RBSolver(solver,reduction_sol,reduction_l,reduction_a)\n\nA RBSolver contains the following information: \n\nThe FE solver solver\nThe reduction strategy for the solution reduction_sol. This information is used to build a projection map representing a low-dimensional approximation subspace (i.e. a trial space) for our differential problem. In the case above, we use a truncated POD with tolerance tol on a set of 20 snapshots. The output is orthogonal with respect to the form inner_prod, i.e. the H^1_0 product. \nThe hyper-reduction strategy for the residual reduction_l. This information is used to build a projection map representing a low-dimensional subspace for the residual, equipped with a reduced integration domain obtained via MDEIM, i.e. the matrix-based empirical interpolation method. A total of 10 residual snapshots is used to compute the output.\nSimilarly, the hyper-reduction strategy for the Jacobian reduction_a.\n\nnote: Note\nOther reduction strategies include fixing the rank of the truncationrank = 5\nPODReduction(rank,inner_prod;nparams=20)and using randomized POD algorithmsPODReduction(tol,inner_prod;nparams=20,sketch=:sprn)A comprehensive documentation on randomized POD algorithms can be found here.","category":"section"},{"location":"steady/#Offline-phase","page":"Usage - Steady problem","title":"Offline phase","text":"The offline phase is the part of the code where the projection maps for the solution, LHS & RHS are computed. This phase is quite expensive to run, but on the upside it can just be run once, provided the outputs are saved to file. For this purpose, we load the well-known packages DrWatson and Serialization\n\nusing DrWatson \nusing Serialization\n\nand define a saving directory for our example\n\ndir = datadir(\"poisson\")\ncreate_dir(dir) \n\nNext, we try loading the offline quantities; if the load fails, we must run the offline phase \n\ntry # try loading offline quantities\n    rbop = load_operator(dir,feop)\ncatch # offline phase\n    rbop = reduced_operator(rbsolver,feop)\n    save(dir,rbop)\nend\n\nThe load might fail, for e.g., if \n\nIt is the first time running the code\nA different directory was used to save the offline structures in previous runs \nFor developers, if the definition of one of the loaded types has changed since it was saved to file \n\nThe offline structures are completely contained in the variable rbop, which is the reduced version of the FE operator feop. To understand better the meaning of this variable, we report the content of the function reduced_operator:\n\nusing GridapROMs.Utils \nusing GridapROMs.ParamSteady\nusing GridapROMs.RBSteady \n\n# compute the solution snapshots \nfesnaps, = solution_snapshots(rbsolver,feop) \n# compute the reduced trial and test spaces \nÛ,V̂ = reduced_spaces(rbsolver,feop,fesnaps)\n# compute the hyper-reduction for LHS & RHS\nâ,l̂ = reduced_weak_form(rbsolver,feop,Û,V̂,fesnaps)\n# definition of reduced operator \nRBOperator(feop,Û,V̂,â,l̂)","category":"section"},{"location":"steady/#Online-phase","page":"Usage - Steady problem","title":"Online phase","text":"This step consists in computing the GridapROMs approximation for any desired parameter. We consider, for e.g., 10 parameters distributed uniformly on D\n\nμₒₙ = realization(D;nparams=10,sampling=:uniform)\n\nand we solve the reduced problem \n\nx̂on,rbstats = solve(rbsolver,rbop,μₒₙ)","category":"section"},{"location":"steady/#Post-processing","page":"Usage - Steady problem","title":"Post processing","text":"In order to test the quality of the approximation x̂on, we can run the following post-processing code \n\nxon,festats = solution_snapshots(solver,feop,μₒₙ)\nperf = eval_performance(rbsolver,feop,rbop,xon,x̂on,festats,rbstats)\nprintln(perf)\n\nIn other words, we first compute the HF solution xon in the online parameters μₒₙ, and then we run the performance tester, which in particular returns\n\nThe relative error ||xon - x̂on|| / ||xon||, averaged on the 10 parameters in μₒₙ. The norm is the one specified by inner_prod, so in our case the H^1_0 product.\nThe speedup in terms of time and memory achieved with respect to the HF simulations. This is done by comparing the variables rbstats and festats, which contain the time (in seconds) and memory allocations (in Gb) of the two algorithms.","category":"section"},{"location":"rbtransient/#GridapROMs.RBTransient","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient","text":"","category":"section"},{"location":"rbtransient/#GridapROMs.RBTransient.HighDimHyperReduction","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.HighDimHyperReduction","text":"abstract type HighDimHyperReduction{A} <: HyperReduction{A} end\n\nHyper reduction strategies employed in high-order (e.g. transient) problems. They feature a field combine, a function used to group the reductions relative to the various Jacobians(in general, more than one in transient problems) in a smart way. We consider, for example, the ODE\n\ntfracdudt - nu Delta u = f   textin   Ω times 0T\n\nsubject to initial/boundary conditions. Upon applying a FE discretization in space, and a θ-method in time, one gets the space-time system\n\nA_theta u_theta = f_theta\n\nwhere\n\nA_theta = beginbmatrix\nA_1 + M  (theta Delta t)      \n- M  (theta Delta t)  A_2 + M  (theta Delta t)     \n - M  (theta Delta t)  A_3 + M  (theta Delta t)    \n  ddots  ddots   \n    - M  (theta Delta t)  A_n + M  (theta Delta t)\nendbmatrix\n\nu_theta = beginbmatrix\n(1-theta)u_0 + theta u_1  hdots  (1-theta)u_n-1 + theta u_n\nendbmatrix^T\n\nf_theta = beginbmatrix\nf_1  hdots  f_n\nendbmatrix^T\n\nA_k = A(t_k-1 + theta Delta t)\n\nf_k = f(t_k-1 + theta Delta t)\n\nNote: instead of multiplying A_theta by u_theta, we multiply tildeA_theta by u, where\n\ntildeA_theta = tridiag((1-theta)A_k-1 - M  Delta t theta A_k + M  Delta t 0)\n\nWe now denote with Phi and Psi the spatial and temporal basis obtained by reducing the snapshots associated to the state variable u. The Galerkin projection of the space-time system is equal to hatA_thetahatu = hatf_theta, where hatu is the unknown, and\n\nbeginalign*\nhatA_theta = sumlimits_k=1^n-1 ( (1-θ) Phi^T A_k Phi - Phi^T M Phi  Delta t) otimes Psik-1^T Psik\n  + sumlimits_k=1^n (theta Phi^T A_k Phi + Phi^T M Phi  Delta t) otimes Psik^T Psik \n  = theta A_backwards + (1-theta)A_forwards + (M_backwards + M_forwards)  Delta t \nhatf_theta = sumlimits_k=1^n Phi^T f_k otimes Psik\nendalign*\n\nWe notice that the expression of hatA_theta can be written in a more general form as\n\nhatA_theta = combine_A(A_backwardsA_forwards) + combine_M(M_backwardsM_forwards)\n\nwhere combineA and combineM are two function specific to A and M:\n\nbeginalign*\ncombine_A(xy) = theta y + (1-theta)y \ncombine_M(xy) = (x - y)  Delta t\nendalign*\n\nThe same can be said of any time marching scheme. This is the meaning of the function combine. Note that for a time marching with p interpolation points (e.g. for theta method, p = 2) the combine functions will have to accept p arguments.\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.KroneckerProjection","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.KroneckerProjection","text":"struct KroneckerProjection <: TransientProjection\n  projection_space::Projection\n  projection_time::Projection\nend\n\nProjection operator for transient problems, containing a spatial projection and a temporal one. The space-time projection operator is equal to\n\nprojection_time ⊗ projection_space\n\nwhich, for efficiency reasons, is never explicitly computed\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.KroneckerReduction","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.KroneckerReduction","text":"struct KroneckerReduction{A,B} <: HighDimReduction{A,B}\n  reductions::AbstractVector{<:Reduction}\nend\n\nWrapper for reduction methods in high order problems, such as transient ones. The reduced subspaces are constructed as Kronecker product spaces\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.SequentialReduction","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.SequentialReduction","text":"struct SequentialReduction{A,B} <: HighDimReduction{A,B}\n  reduction::Reduction{A,B}\nend\n\nWrapper for sequential reduction methods in high-order problems, e.g. TT-SVD in transient applications\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.TransientIntegrationDomain","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.TransientIntegrationDomain","text":"struct TransientIntegrationDomain{A<:TransientIntegrationDomainStyle,Ti<:Integer} <: IntegrationDomain\n  domain_style::A\n  domain_space::IntegrationDomain\n  indices_time::Vector{Ti}\nend\n\nIntegration domain for a projection operator in a transient problem\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.time_enrichment-Tuple{Projection, Any}","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.time_enrichment","text":"time_enrichment(red::SupremizerReduction,a_primal::Projection,basis_dual;kwargs...) -> AbstractMatrix\n\nTemporal supremizer enrichment. (Approximate) Procedure:\n\nfor every b_dual ∈ Col(basis_dual)\ncompute Φ_primal_dual = get_basis(a_primal)'*get_basis(b_dual)\ncompute v = kernel(Φ_primal_dual)\ncompute v′ = orth_complement(v,a_primal)\nenrich a_primal = [a_primal,v′]\n\n\n\n\n\n","category":"method"},{"location":"transient/#Usage-Transient-problem","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"In this example we solve a more complicated problem, namely a parameter- and time-dependent version of the Navier-Stokes equations.","category":"section"},{"location":"transient/#FE-code","page":"Usage - Transient problem","title":"FE code","text":"We start by loading the necessary packages  \n\nusing Gridap\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers\nusing GridapSolvers.NonlinearSolvers\nusing DrWatson\nusing Serialization\n\nusing GridapROMs\n\nimport Gridap.MultiField: BlockMultiFieldStyle\n\nNext, we load a DiscreteModel from file (which can be found among the assets of the repo)\n\nmodel_dir = datadir(joinpath(\"models\",\"model_circle_2d.json\"))\nΩₕ = DiscreteModelFromFile(model_dir)\nlabels = get_face_labeling(Ωₕ)\nadd_tag_from_tags!(labels,\"dirichlet0\",[\"walls_p\",\"walls\",\"cylinders_p\",\"cylinders\"])\nadd_tag_from_tags!(labels,\"dirichlet\",[\"inlet\"])\n\nNow, we introduce the space of tuples (μt)\n\ndt = 0.0025\nt0 = 0.0\ntf = 60*dt\n\npdomain = fill([1.0,10.0],3)\ntdomain = t0:dt:tf\nDt = TransientParamSpace(pdomain,tdomain)\n\nThe main difference with respect to the steady case is that we consider as realizations sets of tuples (μt). This allows for a much cleaner representation of the (μt)-dependence in the problem. \n\nnote: Note\n\n\nTimes are not sampled from a TransientParamSpace, in the sense that we consider the sets (μt)  t  t0dttf, where μ is a sampled quantity.\n\nThe way in which we simultaneously evaluate parameter- and time-dependent functions is with the structure TransientParamFunction, which generalizes a ParamFunction to the transient case. For example, we can consider the following Dirichlet datum for our problem\n\nconst W = 0.5\ninflow(μ,t) = abs(1-cos(2π*t/tf)+μ[3]*sin(μ[2]*2π*t/tf)/100)\ng_in(μ,t) = x -> VectorValue(-x[2]*(W-x[2])*inflow(μ,t),0.0)\ngₚₜ_in(μ,t) = parameterize(g_in,μ,t)\ng_0(μ,t) = x -> VectorValue(0.0,0.0)\ngₚₜ_0(μ,t) = parameterize(g_0,μ,t)\n\nwhich we use to define the FE spaces. We employ the Inf-Sup stable P2-P1 (Taylor-Hood) pair for velocity and pressure, respectively:\n\norder = 2\nreffe_u = ReferenceFE(lagrangian,VectorValue{2,Float64},order)\nV = TestFESpace(Ωₕ,reffe_u;conformity=:H1,dirichlet_tags=[\"dirichlet\",\"dirichlet0\"])\nU = TransientTrialParamFESpace(V,[gₚₜ_in,gₚₜ_0])\nreffe_p = ReferenceFE(lagrangian,Float64,order-1)\nQ = TestFESpace(Ωₕ,reffe_p;conformity=:H1)\nP = TransientTrialParamFESpace(Q)\nY = TransientMultiFieldParamFESpace([V,Q];style=BlockMultiFieldStyle())\nX = TransientMultiFieldParamFESpace([U,P];style=BlockMultiFieldStyle())\n\nA TransientTrialParamFESpace extends a traditional TransientTrialFESpace in Gridap, as it allows to provide a (μt)-dependent Dirichlet datum. The same holds for the multi-field version TransientMultiFieldParamFESpace. \n\nnote: Note\n\n\nIn the multi-field scenario, the BlockMultiFieldStyle style should always be used. Check the appropriate documentation of Gridap for more information.\n\nNow we introduce the information related to the numerical integration \n\norder = 2\ndegree = 2*order+1\nτₕ = Triangulation(Ωₕ)\ndΩₕ = Measure(τₕ,degree)\n\nand then the problem's weak formulation \n\nconst Re = 100.0\na(x,μ,t) = μ[1]/Re\na(μ,t) = x->a(x,μ,t)\naμt(μ,t) = parameterize(a,μ,t)\n\nconv(u,∇u) = (∇u')⋅u\ndconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)\nc(u,v,dΩₕ) = ∫( v⊙(conv∘(u,∇(u))) )dΩₕ\ndc(u,du,v,dΩₕ) = ∫( v⊙(dconv∘(du,∇(du),u,∇(u))) )dΩₕ\n\nstiffness(μ,t,(u,p),(v,q),dΩₕ) = ∫(aμt(μ,t)*∇(v)⊙∇(u))dΩₕ - ∫(p*(∇⋅(v)))dΩₕ + ∫(q*(∇⋅(u)))dΩₕ\nmass(μ,t,(uₜ,pₜ),(v,q),dΩₕ) = ∫(v⋅uₜ)dΩₕ\nres(μ,t,(u,p),(v,q),dΩₕ) = ∫(v⋅∂t(u))dΩₕ + stiffness(μ,t,(u,p),(v,q),dΩₕ)\n\nres_nlin(μ,t,(u,p),(v,q),dΩₕ) = c(u,v,dΩₕ)\njac_nlin(μ,t,(u,p),(du,dp),(v,q),dΩₕ) = dc(u,du,v,dΩₕ)\n\nNote that we have split the linear terms of the Navier-Stokes equations from the nonlinear convection terms, allowing us to increase efficiency of the algorithm. Now we introduce two FE operators, one for the linear terms and the other for the nonlinear ones:\n\nτₕ_res = (τₕ,)\nτₕ_jac = (τₕ,)\nτₕ_jac_t = (τₕ,)\ndomains_lin = FEDomains(τₕ_res,(τₕ_jac,τₕ_jac_t))\ndomains_nlin = FEDomains(τₕ_res,(τₕ_jac,))\n\nfeop_lin = TransientLinearParamOperator(res,(stiffness,mass),Dt,\n  X,Y,domains_lin)\nfeop_nlin = TransientParamOperator(res_nlin,jac_nlin,Dt,\n  X,Y,domains_nlin)\n\nfeop = LinearNonlinearTransientParamOperator(feop_lin,feop_nlin)\n\nNext, we define the time marching scheme for our problem, along with a suitable initial condition \n\nu0(x,μ) = VectorValue(0.0,0.0)\nu0(μ) = x->u0(x,μ)\nu0μ(μ) = parameterize(u0,μ)\np0(x,μ) = 0.0\np0(μ) = x->p0(x,μ)\np0μ(μ) = parameterize(p0,μ)\nxh0μ(μ) = interpolate_everywhere([u0μ(μ),p0μ(μ)],X(μ,t0))\n\nnls = NewtonSolver(LUSolver();rtol=1e-10)\nθ = 1\nfesolver = ThetaMethod(nls,dt,θ)","category":"section"},{"location":"transient/#GridapROMs-code","page":"Usage - Transient problem","title":"GridapROMs code","text":"We finally discuss the code relative to the reduced part. As usual we start by defining the RBSolver of the problem \n\ncoupling((du,dp),(v,q)) = ∫(dp*(∇⋅(v)))dΩₕ\nenergy((du,dp),(v,q)) = ∫(∇(v)⊙∇(du))dΩₕ + ∫(dp*q)dΩₕ\n\ntol = 1e-4\nstate_reduction = HighDimReduction(coupling,tol,energy;nparams=50,sketch=:sprn)\nrbsolver = RBSolver(fesolver,state_reduction;nparams_res=40,nparams_jac=40)\n\n\nThe main novelty is the use of transient reduction techniques. In particular:\n\nA HighDimReduction provides the information related to a reduction in space, and a reduction in time. \nA HighDimMDEIMHyperReduction provides the information related to a hyper-reduction in space, and a hyper-reduction in time. This is automatically built within the RBSolver, simply by passing as keyword argument the number of parameters for residual and Jacobians.\nWhenever we provide a coupling variable in the reduction strategy, a reduction of type SupremizerReduction is returned. This type simply acts as a wrapper for a reduction strategy (of type HighDimReduction in our case), and has the scope of performing a supremizer enrichment for the stabilization of the reduced problem. Check this reference for more details on supremizer stabilizations. They are useful, for e.g., when reducting saddle-point problems such as the Stokes or Navier-Stokes equations.\n\nThe subsequent steps procede as in a steady problem:\n\nusing DrWatson \nusing Serialization\n\ndir = datadir(\"navier-stokes\")\ncreate_dir(dir) \n\ntry # try loading offline quantities\n    rbop = load_operator(dir,feop)\ncatch # offline phase\n    rbop = reduced_operator(rbsolver,feop,xh0μ)\n    save(dir,rbop)\nend\n\nμₒₙ = realization(Dt;nparams=10,sampling=:uniform)\nx̂on,rbstats = solve(rbsolver,rbop,μₒₙ,xh0μ)\n\nxon,festats = solution_snapshots(rbsolver,feop,μₒₙ,xh0μ)\nperf = eval_performance(rbsolver,feop,rbop,xon,x̂on,festats,rbstats)\nprintln(perf)","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributing to GridapROMs ==\n\nBy contributing to GridapROMs, you accept and agree to the following Developer Certificate of Origin Version 1.1 (see below) for all your contributions.\n\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"section"},{"location":"contributing/#GridapROMs-Style-Guides","page":"Contributing","title":"GridapROMs Style Guides","text":"2 spaces for indentation level\nNo trailing white spaces\nCamelCase for typenames\nPluralized CamelCase for files that implement a type\nCamelCasesTests for CamelCase type test file\nUse lowercase for methods, with underscores only when necessary\nUse whitespace for readability\n80 characterl line length limit\nUse method! for muting methods\nWrap multiline expressions in parentheses to avoid errors\n\nSee the Julia CONTRIBUTING.md for further information.","category":"section"},{"location":"tproduct/#GridapROMs.TProduct","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct","text":"","category":"section"},{"location":"tproduct/#GridapROMs.TProduct.MatrixOrTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.MatrixOrTensor","text":"const MatrixOrTensor = Union{AbstractMatrix,AbstractRankTensor}\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.AbstractRankTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.AbstractRankTensor","text":"abstract type AbstractRankTensor{D,K} end\n\nType representing a tensor a of dimension D and rank K, i.e. assuming the form\n\na = sumlimits_k=1^K a_1^k otimes cdots otimes a_D^k\n\nSubtypes:\n\nRank1Tensor\nGenericRankTensor\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.BlockRankTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.BlockRankTensor","text":"struct BlockRankTensor{A<:AbstractRankTensor,N} <: AbstractArray{A,N}\n  array::Array{A,N}\nend\n\nMulti-field version of a AbstractRankTensor\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.GenericRankTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.GenericRankTensor","text":"struct GenericRankTensor{D,K,A<:AbstractArray} <: AbstractRankTensor{D,K}\n  decompositions::Vector{Rank1Tensor{D,A}}\nend\n\nStructure representing a generic rank-K tensor, i.e. assuming the form\n\na = sumlimits_k=1^K a_1^k otimes cdots otimes a_D^k\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.Rank1Tensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.Rank1Tensor","text":"struct Rank1Tensor{D,A<:AbstractArray} <: AbstractRankTensor{D,1}\n  factors::Vector{A}\nend\n\nStructure representing rank-1 tensors, i.e. assuming the form\n\na = a_1 otimes cdots otimes a_D\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductDiscreteModel","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductDiscreteModel","text":"TProductDiscreteModel{D,A,B} <: DiscreteModel{D,D} end\n\nTensor product discrete model, storing a vector of 1-D models models_1d of length D, and the D-dimensional model model defined as their tensor product.\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductFESpace","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductFESpace","text":"struct TProductFESpace{S} <: SingleFieldFESpace\n  space::S\n  spaces_1d::Vector{<:SingleFieldFESpace}\n  trian::TProductTriangulation\nend\n\nTensor product single field FESpace, storing a vector of 1-D FESpaces spaces_1d of length D, and the D-dimensional FESpace space defined as their tensor product. The tensor product triangulation trian is provided as a field to avoid incompatibility issues when passing to MultiField scenarios\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductMeasure","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductMeasure","text":"struct TProductMeasure{A,B} <: Measure\n  measure::A\n  measures_1d::B\nend\n\nTensor product measure, storing a vector of 1-D measures measures_1d of length D, and the D-dimensional measure measure defined as their tensor product.\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductSparseMatrixAssembler","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductSparseMatrixAssembler","text":"TProductSparseMatrixAssembler{A<:SparseMatrixAssembler} <: SparseMatrixAssembler\n\nAssembly-related information when constructing a AbstractRankTensor\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductTriangulation","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductTriangulation","text":"TProductTriangulation{Dt,Dp,A,B,C} <: Triangulation{Dt,Dp}\n\nTensor product triangulation, storing a tensor product model, a vector of 1-D triangulations trians_1d of length D, and the D-dimensional triangulation trian defined as their tensor product.\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductBlockSparseMatrixAssembler-Tuple{Gridap.MultiField.MultiFieldFESpace, Gridap.MultiField.MultiFieldFESpace}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductBlockSparseMatrixAssembler","text":"TProductBlockSparseMatrixAssembler(trial::MultiFieldFESpace,test::MultiFieldFESpace\n  ) -> TProductSparseMatrixAssembler\n\nReturns a TProductSparseMatrixAssembler in a MultiField scenario\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_1d_tags-Union{Tuple{D}, Tuple{TProductDiscreteModel{D, A} where A<:(Gridap.Geometry.CartesianDiscreteModel{D}), Any}} where D","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_1d_tags","text":"get_1d_tags(model::TProductDiscreteModel,tags) -> Vector{Vector{Int8}}\n\nFetches the tags of the tensor product 1D models corresponding to the tags of the D-dimensional model tags. The length of the output is D\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_decomposition-Tuple{GridapROMs.TProduct.AbstractRankTensor, Integer}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_decomposition","text":"get_decomposition(a::AbstractRankTensor,k::Integer) -> Vector{<:AbstractArray}\n\nFor a tensor a of dimension D and rank K assuming the form\n\na = sumlimits_k=1^K a_1^k otimes cdots otimes a_D^k\n\nreturns the decomposition relative to the kth rank:\n\na_1^k hdots  a_D^k\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_tp_fe_basis-Tuple{TProductFESpace}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_tp_fe_basis","text":"get_tp_fe_basis(f::TProductFESpace) -> TProductFEBasis\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_tp_trial_fe_basis-Tuple{TProductFESpace}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_tp_trial_fe_basis","text":"get_tp_trial_fe_basis(f::TProductFESpace) -> TProductFEBasis\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.tproduct_array-Tuple{Vector{<:AbstractArray}}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.tproduct_array","text":"tproduct_array(arrays_1d::Vector{<:AbstractArray}) -> Rank1Tensor\ntproduct_array(op,arrays_1d::Vector{<:AbstractArray},gradients_1d::Vector{<:AbstractArray},args...) -> GenericRankTensor\n\nReturns a AbstractRankTensor storing the arrays arrays_1d (usually matrices) arising from an integration routine on D 1-d triangulations whose tensor product gives a D-dimensional triangulation. In the absence of the field gradients_1d, the output is a Rank1Tensor; when provided, the output is a GenericRankTensor\n\ntproduct_array(arrays_1d::Vector{<:BlockArray}) -> BlockRankTensor\ntproduct_array(op,arrays_1d::Vector{<:BlockArray},gradients_1d::Vector{<:BlockArray},args...) -> BlockRankTensor\n\nGeneralization of the previous functions to multi-field scenarios\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils","page":"GridapROMs.Utils","title":"GridapROMs.Utils","text":"","category":"section"},{"location":"utils/#GridapROMs.Utils.ArrayContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.ArrayContribution","text":"const ArrayContribution{T,N} = Contribution{<:Union{AbstractArray{T,N},ArrayBlock{T,N}}}\n\nContribution whose field values are AbstractArrays\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.Contribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.Contribution","text":"struct Contribution{V}\n  values::Tuple{Vararg{V}}\n  trians::Tuple{Vararg{Triangulation}}\nend\n\nCollection of values corresponding to a set of triangulations. Similarly to DomainContribution, the values can be accessed by indexing the corresponding triangulation.\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.FEDomains","page":"GridapROMs.Utils","title":"GridapROMs.Utils.FEDomains","text":"struct FEDomains{A,B}\n  domains_res::A\n  domains_jac::B\nend\n\nFields:\n\ndomains_res: triangulations relative to the residual (nothing by default)\ndomains_jac: triangulations relative to the Jacobian (nothing by default)\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.JointDomains","page":"GridapROMs.Utils","title":"GridapROMs.Utils.JointDomains","text":"struct JointDomains <: TriangulationStyle end\n\nTrait for a FE operator indicating that residuals/Jacobians in this operator should be computed summing the contributions relative to each triangulation as occurs in Gridap\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.LinearEq","page":"GridapROMs.Utils","title":"GridapROMs.Utils.LinearEq","text":"\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.LinearNonlinearEq","page":"GridapROMs.Utils","title":"GridapROMs.Utils.LinearNonlinearEq","text":"\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.MatrixContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.MatrixContribution","text":"const MatrixContribution{T} = ArrayContribution{T,2}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.NonlinearEq","page":"GridapROMs.Utils","title":"GridapROMs.Utils.NonlinearEq","text":"\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.OperatorType","page":"GridapROMs.Utils","title":"GridapROMs.Utils.OperatorType","text":"\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.PartialDerivative","page":"GridapROMs.Utils","title":"GridapROMs.Utils.PartialDerivative","text":"struct PartialDerivative{N} <: Function end\n\nGridap Map that implements a partial derivative\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.SplitDomains","page":"GridapROMs.Utils","title":"GridapROMs.Utils.SplitDomains","text":"struct SplitDomains <: TriangulationStyle end\n\nTrait for a FE operator indicating that residuals/Jacobians in this operator should be computed keeping the contributions relative to each triangulation separate\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.TriangulationStyle","page":"GridapROMs.Utils","title":"GridapROMs.Utils.TriangulationStyle","text":"abstract type TriangulationStyle <: GridapType end\n\nSubtypes:\n\nJointDomains\nSplitDomains\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.TupOfArrayContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.TupOfArrayContribution","text":"const TupOfArrayContribution{T} = Tuple{Vararg{ArrayContribution{T}}}\n\nSpecifically allows to deal with tuples of Jacobians in unsteady settings\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.VectorContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.VectorContribution","text":"const VectorContribution{T} = ArrayContribution{T,1}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.∂₁","page":"GridapROMs.Utils","title":"GridapROMs.Utils.∂₁","text":"const ∂₁ = PartialDerivative{1}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.∂₂","page":"GridapROMs.Utils","title":"GridapROMs.Utils.∂₂","text":"const ∂₂ = PartialDerivative{2}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.∂₃","page":"GridapROMs.Utils","title":"GridapROMs.Utils.∂₃","text":"const ∂₃ = PartialDerivative{3}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.collect_cell_matrix_for_trian-Tuple{Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace, Gridap.CellData.DomainContribution, Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.collect_cell_matrix_for_trian","text":"function collect_cell_matrix_for_trian(\n  trial::FESpace,\n  test::FESpace,\n  a::DomainContribution,\n  strian::Triangulation\n  ) -> Tuple{Vector{<:Any},Vector{<:Any},Vector{<:Any}}\n\nComputes the cell-wise data needed to assemble a global sparse matrix for a given input triangulation strian\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.collect_cell_vector_for_trian-Tuple{Gridap.FESpaces.FESpace, Gridap.CellData.DomainContribution, Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.collect_cell_vector_for_trian","text":"function collect_cell_vector_for_trian(\n  test::FESpace,\n  a::DomainContribution,\n  strian::Triangulation\n  ) -> Tuple{Vector{<:Any},Vector{<:Any}}\n\nComputes the cell-wise data needed to assemble a global vector for a given input triangulation strian\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.compute_error-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Vararg{Any}}} where {T, N}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.compute_error","text":"compute_error(\n  sol::AbstractArray{T,N},\n  sol_approx::AbstractArray{T,N},\n  args...\n  ) where {T,N} -> Number\n\nComputes the error between sol and sol_approx, by default in the Euclidean norm. A different norm (usually represented by a sparse matrix) can be provided as an argument.\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.compute_relative_error-Tuple{AbstractArray, AbstractArray, Vararg{Any}}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.compute_relative_error","text":"compute_relative_error(\n  sol::AbstractArray{T,N},\n  sol_approx::AbstractArray{T,N},\n  args...\n  ) where {T,N} -> Number\n\nComputes the relative error between sol and sol_approx, by default in the Euclidean norm. A different norm (usually represented by a sparse matrix) can be provided as an argument.\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.compute_speedup-Tuple{GridapROMs.Utils.CostTracker, GridapROMs.Utils.CostTracker}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.compute_speedup","text":"compute_speedup(t1::CostTracker,t2::CostTracker) -> Speedup\n\nComputes the speedup the tracker t2 achieves with respect to t1, in time and in memory footprint\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.contribution-Tuple{Any, Any}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.contribution","text":"contribution(f,trians) -> Contribution\n\nConstructor of a Contribution that allows do-block syntax. f is a function such that\n\nvalues[i] = f(trians[i]) for i...\n\nThis constructor first builds the tuple of values, then builds the Contribution object from values and trians\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.get_parent-Tuple{Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.get_parent","text":"get_parent(t::Triangulation) -> Triangulation\n\nWhen t is a triangulation view, returns its parent; throws an error when t is not a triangulation view\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.get_polynomial_order-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.get_polynomial_order","text":"get_polynomial_order(f::FESpace) -> Integer\n\nRetrieves the polynomial order of f\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.get_polynomial_orders-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.get_polynomial_orders","text":"get_polynomial_orders(fs::FESpace) -> Integer\n\nRetrieves the polynomial order of fs for every dimension\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.is_parent-Union{Tuple{A}, Tuple{Dp}, Tuple{Dt}, Tuple{Gridap.Geometry.BodyFittedTriangulation, Gridap.Geometry.BodyFittedTriangulation{Dt, Dp, A, <:Gridap.Geometry.GridView}}} where {Dt, Dp, A}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.is_parent","text":"is_parent(parent::Triangulation,child::Triangulation) -> Bool\n\nReturns true if child is a triangulation view of parent, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.isapprox_parent-Union{Tuple{A}, Tuple{Dp}, Tuple{Dt}, Tuple{Gridap.Geometry.BodyFittedTriangulation, Gridap.Geometry.BodyFittedTriangulation{Dt, Dp, A, <:Gridap.Geometry.GridView}}} where {Dt, Dp, A}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.isapprox_parent","text":"isapprox_parent(parent::Triangulation,child::Triangulation) -> Bool\n\nSame as is_parent, but with a relaxed check (it could return true even when the objectid comparison fails)\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.order_domains-Tuple{Any, Any}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.order_domains","text":"order_domains(\n  parents::Tuple{Vararg{Triangulation}},\n  children::Tuple{Vararg{Triangulation}}\n  ) -> Tuple{Vararg{Triangulation}}\n\nOrders the triangulation children in the same way as the triangulation parents\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady","text":"","category":"section"},{"location":"param_steady/#GridapROMs.ParamSteady.GenericParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.GenericParamOperator","text":"struct GenericParamOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: ParamOperator{O,T}\n  op::ParamFEOperator{O,T}\nend\n\nWrapper that transforms a ParamFEOperator into an ParamOperator\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.JointParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.JointParamFEOperator","text":"const JointParamFEOperator{O<:UnEvalOperatorType} = ParamFEOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.JointParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.JointParamOperator","text":"const JointParamOperator{O<:UnEvalOperatorType} = ParamOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearNonlinearParamEq","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearNonlinearParamEq","text":"struct LinearNonlinearParamEq <: UnEvalOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearNonlinearParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearNonlinearParamFEOperator","text":"struct LinearNonlinearParamFEOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: ParamFEOperator{O,T}\n  op_linear::ParamFEOperator\n  op_nonlinear::ParamFEOperator\nend\n\nInterface to accommodate the separation of terms depending on their linearity in a nonlinear problem. This allows to build and store once and for all linear residuals/Jacobians, and in the Newton-like iterations only evaluate and assemble only the nonlinear components\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearParamEq","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearParamEq","text":"struct LinearParamEq <: UnEvalOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.NonlinearParamEq","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.NonlinearParamEq","text":"struct NonlinearParamEq <: UnEvalOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamFEOpFromWeakForm","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamFEOpFromWeakForm","text":"struct ParamFEOpFromWeakForm{O<:UnEvalOperatorType,T<:TriangulationStyle} <: ParamFEOperator{O,T}\n  res::Function\n  jac::Function\n  pspace::ParamSpace\n  assem::Assembler\n  trial::FESpace\n  test::FESpace\n  domains::FEDomains\nend\n\nMost standard instance of a parametric FE operator\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamFEOperator","text":"abstract type ParamFEOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: FEOperator end\n\nParametric extension of a FEOperator in Gridap. Compared to a standard FEOperator, there are the following novelties:\n\na ParamSpace is provided, so that parametric realizations can be extracted directly from the ParamFEOperator\na function representing a norm matrix is provided, so that errors in the desired norm can be automatically computed\n\nSubtypes:\n\nParamFEOpFromWeakForm\nLinearNonlinearParamFEOperator\nTransientParamFEOperator\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamOperator","text":"abstract type ParamOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: NonlinearParamOperator end\n\nType representing algebraic operators when solving parametric differential problems\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.SplitParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.SplitParamFEOperator","text":"const SplitParamFEOperator{O<:UnEvalOperatorType} = ParamFEOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.SplitParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.SplitParamOperator","text":"const SplitParamOperator{O<:UnEvalOperatorType} = ParamOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.UnEvalOperatorType","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.UnEvalOperatorType","text":"abstract type UnEvalOperatorType <: GridapType end\n\nType representing operators that are not evaluated yet. This may include operators representing transient problems (although the implementation in Gridap differs), parametric problems, and a combination thereof. Could become a supertype of ODEOperatorType in Gridap\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearParamFEOperator-Tuple{Function, Function, Any, Any, Any}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearParamFEOperator","text":"LinearParamFEOperator(res::Function,jac::Function,pspace,trial,test,args...\n  ) -> ParamFEOperator{LinearParamEq,TriangulationStyle}\n\nReturns a linear parametric FE operator\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_dof_map_at_domains-Tuple{ParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_dof_map_at_domains","text":"get_dof_map_at_domains(op::ParamFEOperator) -> Contribution\n\nReturns the residual dof map restricted to every residual triangulation\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_fe_operator-Tuple{ParamOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_fe_operator","text":"get_fe_operator(op::ParamOperator) -> ParamFEOperator\n\nFetches the underlying FE operator of an algebraic operator op\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_param_space-Tuple{ParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_param_space","text":"get_param_space(feop::ParamFEOperator) -> ParamSpace\nget_param_space(feop::TransientParamFEOperator) -> TransientParamSpace\n\nReturns the space of parameters contained in feop\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_sparse_dof_map_at_domains-Tuple{ParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_sparse_dof_map_at_domains","text":"get_sparse_dof_map_at_domains(op::ParamFEOperator) -> Contribution\n\nReturns the Jacobian dof map restricted to every Jacobian triangulation\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.join_operators-Tuple{LinearNonlinearParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.join_operators","text":"join_operators(op::LinearNonlinearParamFEOperator) -> ParamFEOperator\n\nJoins the linear/nonlinear parts of the operator and returns the resulting operator\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.Utils.change_domains-Tuple{GridapROMs.ParamSteady.JointParamFEOperator, Vararg{Any}}","page":"GridapROMs.ParamSteady","title":"GridapROMs.Utils.change_domains","text":"change_domains(op::ParamFEOperator,args...) -> ParamFEOperator\n\nChanges the triangulations for residual/jacobian; the resulting operator will have the same TriangulationStyle trait as the one of the input\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.Utils.set_domains-Tuple{GridapROMs.ParamSteady.JointParamFEOperator, Vararg{Any}}","page":"GridapROMs.ParamSteady","title":"GridapROMs.Utils.set_domains","text":"set_domains(op::ParamFEOperator,args...) -> JointParamFEOperator\n\nFixes the triangulations for residual/jacobian; the resulting operator will have the trait JointDomains activated\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures","text":"","category":"section"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamArray","text":"abstract type AbstractParamArray{T,N,A<:AbstractArray{T,N}} <: AbstractParamData{A,N} end\n\nType representing parametric abstract arrays of type A. Subtypes:\n\nParamArray\nParamSparseMatrix\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamArray3D","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamArray3D","text":"const AbstractParamArray3D{T} = AbstractParamArray{T,3,<:AbstractArray{T,3}}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamData","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamData","text":"abstract type AbstractParamData{T,N} <: AbstractArray{T,N} end\n\nType representing generic parametric quantities. Subtypes:\n\nParamNumber\nAbstractParamArray\nAbstractSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamFunction","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamFunction","text":"abstract type AbstractParamFunction{P<:Realization} <: Function end\n\nRepresentation of parametric functions with domain a parametric space. Subtypes:\n\nParamFunction\nTransientParamFunction\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamMatrix","text":"const AbstractParamMatrix{T} = AbstractParamArray{T,2,<:AbstractMatrix{T}}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamVector","text":"const AbstractParamVector{T} = AbstractParamArray{T,1,<:AbstractVector{T}}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractRealization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractRealization","text":"abstract type AbstractRealization end\n\nType representing parametric realizations, i.e. samples extracted from a given parameter space. Subtypes:\n\nRealization\nTransientRealization\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractSnapshots","text":"abstract type AbstractSnapshots{T,N} <: AbstractParamData{T,N} end\n\nType representing N-dimensional arrays of snapshots. Subtypes must contain the following information:\n\ndata: a (parametric) array\nrealization: a subtype of AbstractRealization, representing the points in the parameter space used to compute the array data\ndof map: a subtype of AbstractDofMap, representing a reindexing strategy for the array data\n\nSubtypes:\n\nSnapshots\nBlockSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockConsecutiveParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockConsecutiveParamArray","text":"const BlockConsecutiveParamArray{T,N,A<:Vector{<:ConsecutiveParamArray{T,N}},B} = BlockParamArray{T,N,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockConsecutiveParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockConsecutiveParamMatrix","text":"const BlockConsecutiveParamMatrix{T,A<:Matrix{<:ConsecutiveParamMatrix{T}},B} = BlockParamMatrix{T,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockConsecutiveParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockConsecutiveParamVector","text":"const BlockConsecutiveParamVector{T,A<:Vector{<:ConsecutiveParamVector{T}},B} = BlockParamVector{T,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockParamArray","text":"struct BlockParamArray{T,N,A<:AbstractArray{<:AbstractParamArray{T,N},N},B<:NTuple{N,AbstractUnitRange{Int}}} <: ParamArray{T,N}\n  data::A\n  axes::B\nend\n\nIs to a ParamArray as a BlockArray is to a regular AbstractArray\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockParamMatrix","text":"const BlockParamMatrix{T,A,B} = BlockParamArray{T,2,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockParamVector","text":"const BlockParamVector{T,A,B} = BlockParamArray{T,1,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockSnapshots","text":"struct BlockSnapshots{S<:Snapshots,N} <: AbstractSnapshots{S,N}\n  array::Array{S,N}\n  touched::Array{Bool,N}\nend\n\nBlock container for Snapshots of type S in a MultiField setting. This type is conceived similarly to ArrayBlock in Gridap\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamArray","text":"struct ConsecutiveParamArray{T,N,M,A<:AbstractArray{T,M}} <: ParamArray{T,N}\n  data::A\nend\n\nParametric array with entries stored consecutively in memory. It is characterized by an inner size equal to size(data)[1:N], and parametric length equal to size(data,N+1), where data is an AbstractArray of dimension M = N+1\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamMatrix","text":"const ConsecutiveParamMatrix{T,A<:AbstractArray{T,3}} = ConsecutiveParamArray{T,2,3,A}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSC","text":"struct ConsecutiveParamSparseMatrixCSC{Tv,Ti<:Integer,A<:AbstractMatrix{Tv}} <: ParamSparseMatrixCSC{Tv,Ti}\n  m::Int64\n  n::Int64\n  colptr::Vector{Ti}\n  rowval::Vector{Ti}\n  data::A\nend\n\nRepresents a vector of sparse matrices in CSC format, with entries stored consecutively in memory. For sake of coherence, an instance of ConsecutiveParamSparseMatrixCSC inherits from AbstractMatrix{<:SparseMatrixCSC{Tv,Ti} rather than AbstractVector{<:SparseMatrixCSC{Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSC{Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSR","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSR","text":"struct ConsecutiveParamSparseMatrixCSR{Bi,Tv,Ti<:Integer,A<:AbstractMatrix{Tv}} <: ParamSparseMatrixCSR{Bi,Tv,Ti}\n  m::Int64\n  n::Int64\n  rowptr::Vector{Ti}\n  colval::Vector{Ti}\n  data::A\nend\n\nRepresents a vector of sparse matrices in CSR format, with entries stored consecutively in memory. For sake of coherence, an instance of ConsecutiveParamSparseMatrixCSR inherits from AbstractMatrix{<:SparseMatrixCSR{Bi,Tv,Ti} rather than AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamVector","text":"const ConsecutiveParamVector{T,A<:AbstractArray{T,2}} = ConsecutiveParamArray{T,1,2,A}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamBlock","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamBlock","text":"struct GenericParamBlock{A} <: ParamBlock{A}\n  data::Vector{A}\nend\n\nMost standard implementation of a ParamBlock\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamMatrix","text":"struct GenericParamMatrix{Tv,Ti} <: ParamArray{Tv,2}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\n  nrows::Vector{Ti}\nend\n\nParametric matrix with entries stored non-consecutively in memory\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSC","text":"struct GenericParamSparseMatrixCSC{Tv,Ti<:Integer} <: ParamSparseMatrixCSC{Tv,Ti}\n  m::Int64\n  n::Int64\n  colptr::Vector{Ti}\n  rowval::Vector{Ti}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\nend\n\nRepresents a vector of sparse matrices in CSC format, with entries stored non-consecutively in memory. For sake of coherence, an instance of GenericParamSparseMatrixCSC inherits from AbstractMatrix{<:SparseMatrixCSC{Tv,Ti} rather than AbstractVector{<:SparseMatrixCSC{Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSC{Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSR","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSR","text":"struct GenericParamSparseMatrixCSR{Bi,Tv,Ti<:Integer} <: ParamSparseMatrixCSR{Bi,Tv,Ti}\n  m::Int64\n  n::Int64\n  rowptr::Vector{Ti}\n  colval::Vector{Ti}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\nend\n\nRepresents a vector of sparse matrices in CSR format, with entries stored non-consecutively in memory. For sake of coherence, an instance of GenericParamSparseMatrixCSR inherits from AbstractMatrix{<:SparseMatrixCSR{Bi,Tv,Ti} rather than AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamVector","text":"struct GenericParamVector{Tv,Ti} <: ParamArray{Tv,1}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\nend\n\nParametric vector with entries stored non-consecutively in memory\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericSnapshots","text":"struct GenericSnapshots{T,N,I,R,A} <: Snapshots{T,N,I,R,A}\n  data::A\n  dof_map::I\n  realization::R\nend\n\nMost standard implementation of a Snapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericTransientRealization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericTransientRealization","text":"struct GenericTransientRealization{P,T,A} <: TransientRealization{P,T}\n  params::P\n  times::A\n  t0::T\nend\n\nMost standard implementation of a TransientRealization.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.HaltonSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.HaltonSampling","text":"struct HaltonSampling <: SamplingStyle\n  start::Int\nend\n\nSampling according to a Halton sequence\n\nnote: Note\n\n\nHalton is a sequence, not a distribution, hence this sampling strategy repeats   realizations since the draws are not randomized; to draw different parameters,   one needs to provide a starting point in the sequence (start = 1 by default)\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.LatinHypercubeSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.LatinHypercubeSampling","text":"struct LatinHypercubeSampling <: SamplingStyle end\n\nSampling according to a Latin HyperCube distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.NormalSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.NormalSampling","text":"struct NormalSampling <: SamplingStyle end\n\nSampling according to a normal distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamArray","text":"abstract type ParamArray{T,N} <: AbstractParamArray{T,N,Array{T,N}} end\n\nType representing parametric arrays of type A. Subtypes:\n\nTrivialParamArray\nConsecutiveParamArray\nGenericParamVector\nGenericParamMatrix\nBlockParamArray\n\nAlso acts as a constructor according to the following rules:\n\nParamArray(A::AbstractArray{<:Number}) -> ParamNumber\nParamArray(A::AbstractArray{<:Number},plength::Int) -> TrivialParamArray\nParamArray(A::AbstractVector{<:AbstractArray}) -> ParamArray\nParamArray(A::AbstractVector{<:AbstractSparseMatrix}) -> ParamSparseMatrix\nParamArray(A::AbstractArray{<:ParamArray}) -> BlockParamArray\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamBlock","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamBlock","text":"abstract type ParamBlock{A} end\n\nType representing cell-wise quantities defined during the integration routine. They are primarily used when lazily evaluating parametric quantities on the mesh. The implementation of the lazy interface mimics that of ArrayBlock in Gridap. Subtypes: -GenericParamBlock -TrivialParamBlock\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamFunction","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamFunction","text":"struct ParamFunction{F,P} <: AbstractParamFunction{P}\n  fun::F\n  params::P\nend\n\nRepresentation of parametric functions with domain a parametric space. Given a function f : Ω₁ × ... × Ωₙ × D, where D is a ParamSpace, the evaluation of f in μ ∈ D returns the restriction of f to Ω₁ × ... × Ωₙ\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamMatrix","text":"const ParamMatrix{T} = ParamArray{T,2}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamNumber","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamNumber","text":"struct ParamNumber{T<:Number,A<:AbstractVector{T}} <: AbstractParamData{T,1}\n  data::A\nend\n\nUsed as a wrapper for non-array structures, e.g. factorizations or numbers\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSpace","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSpace","text":"struct ParamSpace{P<:AbstractVector{<:AbstractVector},S<:SamplingStyle} <: AbstractSet{Realization}\n  param_domain::P\n  sampling_style::S\nend\n\nFields:\n\nparam_domain: domain of definition of the parameters\nsampling_style: distribution on param_domain according to which we can sample the parameters (by default it is set to HaltonSampling)\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSparseMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSparseMatrix","text":"abstract type ParamSparseMatrix{Tv,Ti,A<:AbstractSparseMatrix{Tv,Ti}\n  } <: AbstractParamArray{Tv,2,A} end\n\nType representing parametric abstract sparse matrices of type A. Subtypes:\n\nParamSparseMatrixCSC\nParamSparseMatrixCSR\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSparseMatrixCSC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSparseMatrixCSC","text":"abstract type ParamSparseMatrixCSC{Tv,Ti} <: ParamSparseMatrix{Tv,Ti,SparseMatrixCSC{Tv,Ti}} end\n\nType representing parametric sparse matrices in CSC format. Subtypes:\n\nConsecutiveParamSparseMatrixCSC\nGenericParamSparseMatrixCSC\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSparseMatrixCSR","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSparseMatrixCSR","text":"abstract type ParamSparseMatrixCSR{Bi,Tv,Ti} <: ParamSparseMatrix{Tv,Ti,SparseMatrixCSR{Bi,Tv,Ti}} end\n\nType representing parametric sparse matrices in CSR format. Subtypes:\n\nConsecutiveParamSparseMatrixCSR\nGenericParamSparseMatrixCSR\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamVector","text":"const ParamVector{T} = ParamArray{T,1}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamVectorWithEntryInserted","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamVectorWithEntryInserted","text":"struct ParamVectorWithEntryInserted{T,A} <: ParamVector{T}\n  a::A\n  index::Int\n  value::Vector{T}\nend\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamVectorWithEntryRemoved","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamVectorWithEntryRemoved","text":"struct ParamVectorWithEntryRemoved{T,A} <: ParamVector{T}\n  a::A\n  index::Int\nend\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.Realization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.Realization","text":"struct Realization{P<:AbstractVector} <: AbstractRealization\n  params::P\nend\n\nRepresents standard parametric realizations, i.e. samples extracted from a given parameter space. The field params is most commonly a vector of vectors. When the parameters are scalars, they still need to be defined as vectors of vectors of unit length. In other words, we treat the case in which params is a vector of numbers as the case in which params is a vector of one vector.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ReshapedSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ReshapedSnapshots","text":"struct ReshapedSnapshots{T,N,I,R,A,B} <: Snapshots{T,N,I,R,A}\n  data::A\n  param_data::B\n  dof_map::I\n  realization::R\nend\n\nMost standard implementation of a Snapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SamplingStyle","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SamplingStyle","text":"abstract type SamplingStyle end\n\nSubtypes:\n\nUniformSampling\nNormalSampling\nHaltonSampling\nLatinHypercubeSampling\nUniformTensorialSampling\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.Snapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.Snapshots","text":"abstract type Snapshots{T,N,I,R,A} <: AbstractSnapshots{T,N} end\n\nType representing a collection of parametric abstract arrays of eltype T, that are associated with a realization of type R. Unlike AbstractParamArray, which are arrays of arrays, subtypes of Snapshots are arrays of numbers.\n\nSubtypes:\n\nSteadySnapshots\nTransientSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SparseSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SparseSnapshots","text":"\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SteadySnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SteadySnapshots","text":"const SteadySnapshots{T,N,I,R<:Realization,A} = Snapshots{T,N,I,R,A}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TensorialUniformSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TensorialUniformSampling","text":"struct TensorialUniformSampling <: SamplingStyle end\n\nSampling according to a tensorial uniform distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientParamFunction","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientParamFunction","text":"struct TransientParamFunction{F,P,T} <: AbstractParamFunction{P}\n  fun::F\n  params::P\n  times::T\nend\n\nRepresentation of parametric functions with domain a transient parametric space. Given a function f : Ω₁ × ... × Ωₙ × D × [t₁,t₂], where [t₁,t₂] is a temporal domain and D is a ParamSpace, or equivalently f : Ω₁ × ... × Ωₙ × D × [t₁,t₂], where D is a TransientParamSpace, the evaluation of f in (μ,t) ∈ D × [t₁,t₂] returns the restriction of f to Ω₁ × ... × Ωₙ\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientParamSpace","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientParamSpace","text":"struct TransientParamSpace{P<:ParamSpace,T} <: AbstractSet{TransientRealization}\n  parametric_space::P\n  temporal_domain::T\nend\n\nFields:\n\nparametric_space: underlying parameter space\ntemporal_domain: underlying temporal space\n\nIt represents, in essence, the set of tuples (p,t) in parametric_space × temporal_domain\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientRealization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientRealization","text":"abstract type TransientRealization{P<:Realization,T<:Real} <: AbstractRealization end\n\nRepresents temporal parametric realizations, i.e. samples extracted from a given parameter space for every time step in a temporal range. The most obvious application of this type are transient PDEs, where an initial condition is given. Following this convention, the initial time instant is kept separate from the other time steps.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientRealizationAt","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientRealizationAt","text":"struct TransientRealizationAt{P,T} <: TransientRealization{P,T}\n  params::P\n  t::Base.RefValue{T}\nend\n\nRepresents a GenericTransientRealization{P,T} at a certain time instant t. To avoid making it a mutable struct, the time instant t is stored as a Base.RefValue{T}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSnapshots","text":"const TransientSnapshots{T,N,I,R<:TransientRealization,A} = Snapshots{T,N,I,R,A}\n\nTransient specialization of a Snapshots\n\nSubtypes:\n\nTransientSnapshotsWithIC\nModeTransientSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSnapshotsWithIC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSnapshotsWithIC","text":"struct TransientSnapshotsWithIC{T,N,I,R,A,B<:TransientSnapshots{T,N,I,R,A}} <: TransientSnapshots{T,N,I,R,A}\n  initial_data::A\n  snaps::B\nend\n\nStores a TransientSnapshots snaps alongside a parametric initial condition initial_data\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSparseSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSparseSnapshots","text":"\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TrivialParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TrivialParamArray","text":"struct TrivialParamArray{T<:Number,N,A<:AbstractArray{T,N}} <: ParamArray{T,N}\n  data::A\n  plength::Int\nend\n\nWrapper for a non-parametric array data that we wish assumed a parametric length\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TrivialParamBlock","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TrivialParamBlock","text":"struct TrivialParamBlock{A} <: ParamBlock{A}\n  data::A\n  plength::Int\nend\n\nWrapper for a non-paramentric quantity data that we wish assumed a parametric length plength\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.UniformSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.UniformSampling","text":"struct UniformSampling <: SamplingStyle end\n\nSampling according to a uniform distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.eltype2-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.eltype2","text":"eltype2(a) -> Type\n\nReturns the eltype of eltype(a), i.e. it extracts the eltype of a parametric entry of a\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.find_param_length-Tuple","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.find_param_length","text":"find_param_length(a...) -> Int\n\nReturns the parametric length of all parametric quantities. An error is thrown if there are no parametric quantities or if at least two quantities have different parametric length\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_all_data-Tuple{ParamArray}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_all_data","text":"get_all_data(A::ParamArray) -> AbstractArray{<:Any}\n\nReturns all the entries stored in A, assuming A stores its entries consecutively\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_at_time","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_at_time","text":"get_at_time(r::GenericTransientRealization,time) -> TransientRealizationAt\n\nReturns a TransientRealizationAt from a GenericTransientRealization at a time instant specified by time\n\n\n\n\n\n","category":"function"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_final_time-Tuple{GridapROMs.ParamDataStructures.GenericTransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_final_time","text":"get_final_time(r::GenericTransientRealization) -> Real\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_initial_time-Tuple{GridapROMs.ParamDataStructures.GenericTransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_initial_time","text":"get_initial_time(r::GenericTransientRealization) -> Real\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_param_data-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_param_data","text":"get_param_data(a) -> Any\n\nReturns the parametric data of a, usually in the form of a AbstractVector or a NTuple\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_param_entry-Tuple{GridapROMs.ParamDataStructures.AbstractParamArray, Vararg{Any}}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_param_entry","text":"get_param_entry(A::AbstractParamArray{T},i...) where T -> Vector{eltype(T)}\n\nReturns a vector of the entries of A at index i, for every parameter. The length of the output is equals to param_length(A)\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_params-Tuple{GridapROMs.ParamDataStructures.AbstractRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_params","text":"get_params(r::AbstractRealization) -> Realization\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_realization-Tuple{GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_realization","text":"get_realization(s::AbstractSnapshots) -> AbstractRealization\n\nReturns the realizations associated to the snapshots s\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_times-Tuple{TransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_times","text":"get_times(r::TransientRealization) -> Any\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.inneraxes-Tuple{GridapROMs.ParamDataStructures.AbstractParamArray}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.inneraxes","text":"inneraxes(A::AbstractParamArray) -> Tuple{Vararg{Base.OneTo}}\n\nReturns the axes of A for a single parameter\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.innerlength-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.innerlength","text":"innerlength(A) -> Int\n\nReturns the length of A for a single parameter. The total entries of A is equals to param_length(A)*innerlength(A)\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.num_params-Tuple{GridapROMs.ParamDataStructures.AbstractRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.num_params","text":"num_params(r::AbstractRealization) -> Int\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.num_times-Tuple{TransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.num_times","text":"get_times(r::TransientRealization) -> Int\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_eachindex-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_eachindex","text":"param_eachindex(a,i::Integer) -> Any\n\nReturns the parametric range of a 1:param_length(a)\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_getindex-Tuple{Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_getindex","text":"param_getindex(a,i::Integer) -> Any\n\nReturns the parametric entry of a at the index i ∈ {1,...,param_length(a)}\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_length-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_length","text":"param_length(a) -> Int\n\nReturns the parametric length of a\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_setindex!-Tuple{Any, Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_setindex!","text":"param_setindex!(a,v,i::Integer) -> Any\n\nSets the parametric entry of a to v at the index i ∈ {1,...,param_length(a)}\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.parameterize-Tuple{Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.parameterize","text":"parameterize(a,plength::Integer) -> Any\n\nReturns a quantity with parametric length plength from a. When a already possesses a parametric length, i.e. it is a parametrized quantity, it returns a\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.parameterize-Tuple{Function, Realization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.parameterize","text":"parameterize(f::Function,r::Realization) -> ParamFunction\nparameterize(f::Function,r::TransientRealization) -> TransientParamFunction\n\nMethod that parameterizes an input quantity by a realization r\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.realization-Tuple{ParamSpace}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.realization","text":"realization(p::ParamSpace;nparams=1,sampling=get_sampling_style(p),kwargs...) -> Realization\nrealization(p::TransientParamSpace;nparams=1,sampling=get_sampling_style(p),kwargs...) -> TransientRealization\n\nExtraction of a set of nparams parameters from a given parametric space, by default according to the sampling strategy specified in p.\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.shift!-Tuple{GridapROMs.ParamDataStructures.GenericTransientRealization, Real}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.shift!","text":"shift!(r::TransientRealization,δ::Real) -> Nothing\n\nIn-place uniform shifting by a constant δ of the temporal domain in the realization r\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.space_dofs-Union{Tuple{GridapROMs.ParamDataStructures.SteadySnapshots{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.space_dofs","text":"space_dofs(s::SteadySnapshots{T,N}) where {T,N} -> NTuple{N-1,Integer}\nspace_dofs(s::TransientSnapshots{T,N}) where {T,N} -> NTuple{N-2,Integer}\n\nReturns the spatial size of the snapshots\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady","text":"","category":"section"},{"location":"rbsteady/#GridapROMs.RBSteady.AbstractTTCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AbstractTTCore","text":"abstract type AbstractTTCore{T,N} <: AbstractArray{T,N} end\n\nType for nonstandard representations of tensor train cores.\n\nSubtypes:\n\nDofMapCore\nSparseCore\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AdaptiveReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AdaptiveReduction","text":"struct AdaptiveReduction{A,B,R<:DirectReduction{A,B}} <: GreedyReduction{A,B}\n  reduction::R\n  adaptive_nparams::Int\n  adaptive_tol::Float64\n  adaptive_maxiter::Int\nend\n\nNot implemented yet. Will serve as a parameter-adaptivity greedy reduction algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AffineContribution","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AffineContribution","text":"const AffineContribution{V<:Projection} = Contribution{V}\n\nContribution whose field values are Projections\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AffineReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AffineReduction","text":"struct AffineReduction{A,B} <: DirectReduction{A,B}\n  red_style::A\n  norm_style::B\nend\n\nReduction employed when the input data is independent with respect to the considered realization. Therefore, simply considering a number of parameters equal to 1 suffices for this type of reduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.BlockHRProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.BlockHRProjection","text":"struct BlockHRProjection{A,I,N} <: HRProjection{A,I}\n  array::Array{HRProjection{A,I},N}\n  touched::Array{Bool,N}\nend\n\nBlock container for HRProjection of type A in a MultiField setting. This type is conceived similarly to ArrayBlock in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.BlockProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.BlockProjection","text":"struct BlockProjection{A<:HRProjection,N} <: Projection\n  array::Array{A,N}\n  touched::Array{Bool,N}\nend\n\nBlock container for Projection of type A in a MultiField setting. This type is conceived similarly to ArrayBlock in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.DirectReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.DirectReduction","text":"abstract type DirectReduction{A,B} <: Reduction{A,B} end\n\nType representing direct reduction methods, e.g. truncated POD, TTSVD, etc.\n\nSubtypes:\n\nAffineReduction\nPODReduction\nTTSVDReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.DofMapCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.DofMapCore","text":"struct DofMapCore{T,A<:AbstractArray{T,3},B<:AbstractArray} <: AbstractTTCore{T,3}\n  core::A\n  dof_map::B\nend\n\nRepresents a tensor train core core reindexed by means of an index mapping dof_map\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.EnergyNorm","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.EnergyNorm","text":"struct EnergyNorm <: NormStyle\n  norm_op::Function\nend\n\nTrait indicating that the reduction algorithm will produce a basis orthogonal in the norm specified by norm_op. Note: norm_op should represent a symmetric, positive definite bilinear form (matrix)\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.EuclideanNorm","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.EuclideanNorm","text":"struct EuclideanNorm <: NormStyle end\n\nTrait indicating that the reduction algorithm will produce a basis orthogonal in the euclidean norm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.FixedSVDRank","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.FixedSVDRank","text":"struct FixedSVDRank <: ReductionStyle\n  rank::Int\nend\n\nStruct employed when the chosen reduction algorithm is a truncated POD at a rank rank. Check this reference for more details on the truncated POD algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.GenericDomain","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.GenericDomain","text":"struct GenericDomain{T,A} <: IntegrationDomain\n  cells::Vector{Int32}\n  cell_idofs::Table{T,Vector{T},Vector{Int32}}\n  metadata::A\nend\n\nIntegration domain for a projection operator in a steady problem\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.GenericHRProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.GenericHRProjection","text":"struct GenericHRProjection{A,B} <: HRProjection{A,B}\n  basis::A\n  style::B\n  interpolation::Interpolation\nend\n\nGeneric implementation of an HRProjection object\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.GenericRBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.GenericRBOperator","text":"struct GenericRBOperator{O,T,A,B} <: RBOperator{O,T}\n  op::ParamOperator{O,T}\n  trial::RBSpace\n  test::RBSpace\n  lhs::A\n  rhs::B\nend\n\nFields:\n\nop: underlying high dimensional FE operator\ntrial: reduced trial space\ntest: reduced test space\nlhs: hyper-reduced left hand side\nrhs: hyper-reduced right hand side\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.HRParamArray","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.HRParamArray","text":"struct HRParamArray{T,N,A,B,C<:ParamArray{T,N}} <: ParamArray{T,N}\n  fecache::A\n  coeff::B\n  hypred::C\nend\n\nParametric vector returned after the online phase of a hyper-reduction strategy. Fields:\n\nfecache: represents a parametric residual/Jacobian computed via integration on an IntegrationDomain\ncoeff: parameter-dependent coefficient computed during the online phase according to the formula\ncoeff = Φi⁻¹ fecache[i,:]\nwhere (Φi,i) are the interpolation and the reduced integration domain stored in a HyperReduction object.\nhypred: the ouptut of the online phase of a hyper-reduction strategy, acoording to the formula\nhypred = Φrb * coeff\nwhere Φrb is the basis stored in a HyperReduction object\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.HRProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.HRProjection","text":"abstract type HRProjection{A<:ReducedProjection,B<:HyperReduction} <: Projection end\n\nSubtype of a Projection dedicated to the output of a hyper-reduction procedure applied on residual/jacobians of a differential problem. This procedure can be summarized in the following steps:\n\ncompute a snapshots tensor T\nconstruct a Projection Φ by running the function reduction on T\nimplement an interpolation strategy\n\nThere are two types of interpolation strategies:\n\nEmpirical interpolation of the Projection Φ\nRadial basis interpolation over the parameter space\n\nWe recall that a RB method requires the (Petrov-)Galerkin projection of the operators (residuals/Jacobians) on the reduced subspace spanned by Φ:\n\nfor residuals: Φrb = test_basisᵀ Φ\nfor Jacobians: Φrb = test_basisᵀ Φ trial_basis\n\nThe output of this operation is a ReducedProjection. Therefore, a HRProjection is completely characterized by the couple (Φrb,i), where i indicates the chosen interpolation strategy.\n\nSubtypes:\n\nGenericHRProjection\nBlockHRProjection\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.HyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.HyperReduction","text":"abstract type HyperReduction{A} <: Reduction{A,EuclideanNorm} end\n\nType representing a hyper-reduction approximation of residuals/Jacobians of a differential problem. Orthogonality with respect to a norm other than the euclidean is not required for this reduction type.\n\nSubtypes:\n\nMDEIMHyperReduction\nRBFHyperReduction\nHighDimHyperReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.IntegrationDomain","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.IntegrationDomain","text":"abstract type IntegrationDomain end\n\nType representing the set of interpolation rows of a Projection subjected to a EIM approximation. Subtypes:\n\nGenericDomain\nTransientIntegrationDomain\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.InvProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.InvProjection","text":"struct InvProjection <: Projection\n  projection::Projection\nend\n\nRepresents the inverse map of a Projection projection\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.LRApproxRank","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.LRApproxRank","text":"struct LRApproxRank <: ReductionStyle\n  opts::LRAOptions\nend\n\nStruct employed when the chosen reduction algorithm is a randomized POD that leverages the package LowRankApprox. The field opts specifies the options needed to run the randomized POD\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.LinearNonlinearRBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.LinearNonlinearRBOperator","text":"struct LinearNonlinearRBOperator{A<:RBOperator,B<:RBOperator,T} <: RBOperator{LinearNonlinearParamEq,T}\n  op_linear::A\n  op_nonlinear::B\nend\n\nExtends the concept of GenericRBOperator to accommodate the linear/nonlinear splitting of terms in nonlinear applications\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.LocalRBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.LocalRBOperator","text":"struct LocalRBOperator{O,T,A,B} <: RBOperator{O,T}\n  op::ParamOperator{O,T}\n  trial::RBSpace\n  test::RBSpace\n  lhs::A\n  rhs::B\nend\n\nFields:\n\nop: underlying high dimensional FE operator\ntrial: local reduced trial spaces\ntest: local reduced test spaces\nlhs: local hyper-reduced left hand sides\nrhs: local hyper-reduced right hand sides\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.LocalReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.LocalReduction","text":"struct LocalReduction{A,B,R<:Reduction{A,B}} <: Reduction{A,B}\n  reduction::R\n  ncentroids::Int\nend\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MDEIMContribution","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MDEIMContribution","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MDEIMHyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MDEIMHyperReduction","text":"struct MDEIMHyperReduction{A} <: HyperReduction{A}\n  reduction::Reduction{A,EuclideanNorm}\nend\n\nMDEIM struct employed in steady problems\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MDEIMProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MDEIMProjection","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MultiFieldRBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MultiFieldRBSpace","text":"struct MultiFieldRBSpace{S<:MultiFieldFESpace} <: RBSpace{S}\n  space::S\n  subspace::BlockProjection\nend\n\nReduced basis subspace of a MultiFieldFESpace in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.NormStyle","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.NormStyle","text":"abstract type NormStyle end\n\nSubtypes:\n\nEuclideanNorm\nEnergyNorm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.NormedProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.NormedProjection","text":"struct NormedProjection <: Projection\n  projection::Projection\n  norm_matrix::MatrixOrTensor\nend\n\nRepresents a Projection projection spanning a space equipped with an inner product represented by the quantity norm_matrix\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.PODProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.PODProjection","text":"struct PODProjection <: Projection\n  basis::AbstractMatrix\nend\n\nProjection stemming from a truncated proper orthogonal decomposition tpod\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.PODReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.PODReduction","text":"struct PODReduction{A,B} <: DirectReduction{A,B}\n  red_style::A\n  norm_style::B\n  nparams::Int\nend\n\nReduction by means of a truncated POD. The field nparams indicates the number of parameters selected for the computation of the snapshots\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.Projection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.Projection","text":"abstract type Projection <: Map end\n\nRepresents a basis for a n-dimensional vector subspace of a N-dimensional vector space (where N >> n), to be used as a Galerkin projection operator. The kernel of a Projection is n-dimensional, whereas its image is N-dimensional.\n\nSubtypes:\n\nPODProjection\nTTSVDProjection\nNormedProjection\nBlockProjection\nInvProjection\nReducedProjection\nHRProjection\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBFContribution","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBFContribution","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBFHyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBFHyperReduction","text":"struct RBFHyperReduction{A} <: HyperReduction{A}\n  reduction::Reduction{A,EuclideanNorm}\n  strategy::AbstractRadialBasis\nend\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBFProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBFProjection","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBOperator","text":"abstract type RBOperator{O,T} <: ParamOperator{O,T} end\n\nType representing reduced algebraic operators used within a reduced order modelling framework in steady applications. A RBOperator should contain the following information:\n\na reduced test and trial space, computed according to reduced_spaces\na hyper-reduced residual and jacobian, computed according to reduced_weak_form\n\nSubtypes:\n\nGenericRBOperator\nLinearNonlinearRBOperator\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBParamVector","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBParamVector","text":"struct RBParamVector{T,A<:ParamVector{T},B} <: ParamArray{T,1}\n  data::A\n  fe_data::B\nend\n\nParametric vector obtained by applying a Projection on a high-dimensional parametric FE vector fe_data, which is stored (but mostly unused) for conveniency\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBSolver","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBSolver","text":"struct RBSolver{A<:GridapType,B} <: GridapType\n  fesolver::A\n  state_reduction::Reduction\n  residual_reduction::Reduction\n  jacobian_reduction::B\nend\n\nWrapper around a FE solver (e.g. NonlinearSolver or ODESolver in Gridap) with additional information on the reduced basis (RB) method employed to solve a given problem dependent on a set of parameters. A RB method is a projection-based reduced order model where\n\na suitable subspace of a FESpace is sought, of dimension n << Nₕ\na matrix-based discrete empirical interpolation method (e.g. MDEIM) is performed\n\nto approximate the manifold of the parametric residuals and jacobians\n\nthe EIM approximations are compressed with (Petrov-)Galerkin projections\n\nonto the subspace\n\nfor every desired choice of parameters, numerical integration is performed, and\n\nthe resulting n × n system of equations is cheaply solved\n\nIn particular:\n\ntol: tolerance used in the projection-based truncated proper orthogonal decomposition (TPOD) or in the tensor train singular value decomposition (TT-SVD), where a basis spanning the reduced subspace is computed; the value of tol is responsible for selecting the dimension of the subspace, i.e. n = n(tol)\nnparams_state: number of snapshots considered when running TPOD or TT-SVD\nnparams_res: number of snapshots considered when running hyper-reduction for the residual\nnparams_jac: number of snapshots considered when running hyper-reduction for the jacobian\nnparams_test:  number of snapshots considered when computing the error the RB method commits with respect to the FE procedure\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBSpace","text":"abstract type RBSpace <: FESpace end\n\nRepresents a vector subspace of a FESpace.\n\nSubtypes:\n\nSingleFieldRBSpace\nMultiFieldRBSpace\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBVector","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBVector","text":"struct RBVector{T,A<:AbstractVector{T},B} <: AbstractVector{T}\n  data::A\n  fe_data::B\nend\n\nVector obtained by applying a Projection on a high-dimensional FE vector fe_data, which is stored (but mostly unused) for conveniency\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ROMPerformance","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ROMPerformance","text":"struct ROMPerformance\n  error\n  speedup\nend\n\nAllows to compute errors and computational speedups to compare the properties of the algorithm with the FE performance.\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ReducedAlgebraicProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ReducedAlgebraicProjection","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ReducedProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ReducedProjection","text":"abstract type ReducedProjection{A<:AbstractArray} <: Projection end\n\nType representing a Galerkin projection of a Projection onto a reduced subspace represented by another Projection.\n\nSubtypes:\n\nReducedAlgebraicProjection\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.Reduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.Reduction","text":"abstract type Reduction{A<:ReductionStyle,B<:NormStyle} end\n\nType indicating the reduction strategy to employ, and the information regarding the norm with respect to which the reduction should occur.\n\nSubtypes:\n\nDirectReduction\nGreedyReduction\nSupremizerReduction\nHyperReduction\nHighDimReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ReductionStyle","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ReductionStyle","text":"abstract type ReductionStyle end\n\nType indicating the reduction strategy to employ.\n\nSubtypes:\n\nSearchSVDRank\nFixedSVDRank\nLRApproxRank\nTTSVDRanks\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SOPTContribution","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SOPTContribution","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SOPTHyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SOPTHyperReduction","text":"struct SOPTHyperReduction{A} <: HyperReduction{A}\n  reduction::Reduction{A,EuclideanNorm}\nend\n\nS-OPT struct employed in steady problems\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SOPTProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SOPTProjection","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SearchSVDRank","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SearchSVDRank","text":"struct SearchSVDRank <: ReductionStyle\n  tol::Float64\nend\n\nStruct employed when the chosen reduction algorithm is a truncated POD at a tolerance tol. Check this reference for more details on the truncated POD algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SingleFieldRBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SingleFieldRBSpace","text":"struct SingleFieldRBSpace{S<:SingleFieldFESpace} <: RBSpace{S}\n  space::S\n  subspace::Projection\nend\n\nReduced basis subspace of a SingleFieldFESpace in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SparseCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SparseCore","text":"abstract type SparseCore{T,N} <: AbstractTTCore{T,N} end\n\nTensor train cores for sparse matrices.\n\nSubtypes:\n\nSparseCoreCSC\nSparseCoreCSC4D\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SparseCoreCSC","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SparseCoreCSC","text":"struct SparseCoreCSC{T,Ti} <: SparseCore{T,3}\n  array::Array{T,3}\n  sparsity::SparsityCSC{T,Ti}\nend\n\nTensor train cores for sparse matrices in CSC format\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SparseCoreCSC4D","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SparseCoreCSC4D","text":"struct SparseCoreCSC4D{T,Ti} <: SparseCore{T,4}\n  core::SparseCoreCSC{T,Ti}\n  sparse_indexes::Vector{CartesianIndex{2}}\nend\n\nTensor train cores for sparse matrices in CSC format, reshaped as 4D arrays\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SupremizerReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SupremizerReduction","text":"struct SupremizerReduction{A,R<:Reduction{A,EnergyNorm}} <: Reduction{A,EnergyNorm}\n  reduction::R\n  supr_op::Function\n  supr_tol::Float64\nend\n\nWrapper for reduction methods reduction that require an additional step of stabilization, by means of a supremizer enrichment. Check this for more details in a steady setting, and this for more details in a transient setting. The fields supr_op and supr_tol (which is only needed only in transient applications) are respectively the supremizing operator and the tolerance involved in the enrichment. For a saddle point problem with a Jacobian of the form\n\n[ A   Bᵀ   B   0 ]\n\nthis operator is given by the bilinear form representing the matrix Bᵀ.\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TTSVDProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TTSVDProjection","text":"struct TTSVDProjection <: Projection\n  cores::AbstractVector{<:AbstractArray{T,3} where T}\n  dof_map::AbstractDofMap\nend\n\nProjection stemming from a tensor train SVD ttsvd. For reindexing purposes a field dof_map is provided along with the tensor train cores cores\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TTSVDRanks","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TTSVDRanks","text":"struct TTSVDRanks <: ReductionStyle\n  style::Vector{<:ReductionStyle}\nend\n\nStruct employed when the chosen reduction algorithm is a TTSVD, with reduction algorithm at each step specified in the vector of reduction styles style. Check this reference for more details on the TTSVD algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TTSVDReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TTSVDReduction","text":"struct TTSVDReduction{B} <: DirectReduction{TTSVDRanks,B}\n  red_style::TTSVDRanks\n  norm_style::B\n  nparams::Int\nend\n\nReduction by means of a TTSVD. The field nparams indicates the number of parameters selected for the computation of the snapshots\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TrivialSparseCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TrivialSparseCore","text":"struct TrivialSparseCore{T,A<:SparsityPattern} <: SparseCore{T,3}\n  array::Array{T,3}\n  sparsity::A\nend\n\nTrivial tensor train core for sparse matrices format\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.contraction-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{S, 3}}} where {T, S}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.contraction","text":"contraction(Φₗₖ::AbstractArray{T,3},Aₖ::AbstractArray{T,3}) -> AbstractArray{T,4}\ncontraction(Φₗₖ::AbstractArray{T,3},Aₖ::AbstractArray{T,3},Φᵣₖ::AbstractArray{T,3}) -> AbstractArray{T,6}\n\nContraction of tensor train cores, as a result of a (Petrov-)Galerkin projection. The contraction of Aₖ by Φₗₖ is the left-contraction of a TT core Aₖ by a (left, test) TT core Φₗₖ, whereas the contraction of Aₖ by Φᵣₖ is the right-contraction of a TT core Aₖ by a (right, trial) TT core Φᵣₖ. The dimension of the output of a contraction involving N factors is: 3N - N = 2N.\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.contraction-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector{S}}} where {T, S}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.contraction","text":"contraction(basis::AbstractArray,coefficient::AbstractArray) -> AbstractArray\n\nMultiplies a reduced basis basis by a set of reduced coeffiecients coefficient. It acts as a generalized linear combination, since basis might have a dimension higher than 2.\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.cores2basis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.cores2basis","text":"cores2basis(cores::AbstractArray{T,3}...) -> AbstractMatrix\n\nReturns a basis in a matrix format from a list of tensor train cores cores. When also supplying the indexing strategy dof_map, the result is reindexed accordingly\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.create_dir-Tuple{String}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.create_dir","text":"create_dir(dir::String) -> Nothing\n\nRecursive creation of a directory dir; does not do anything if dir exists\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.empirical_interpolation-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.empirical_interpolation","text":"empirical_interpolation(a::Projection) -> (AbstractVector,AbstractMatrix)\n\nComputes the EIM of a. The outputs are:\n\na vector of integers i, corresponding to a list of interpolation row indices\na matrix Φi = view(Φ,i), where Φ = get_basis(a). This quantity represents the restricted basis on the set of interpolation rows i\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.enrich!-Tuple{SupremizerReduction, BlockProjection, BlockArrays.BlockMatrix{T} where T, BlockArrays.BlockMatrix{T} where T}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.enrich!","text":"enrich!(\n  red::SupremizerReduction,\n  a::BlockProjection,\n  norm_matrix::MatrixOrTensor,\n  supr_matrix::MatrixOrTensor) -> Nothing\n\nIn-place augmentation of the primal block of a BlockProjection a. This function has the purpose of stabilizing the reduced equations stemming from a saddle point problem\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.eval_performance-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots, GridapROMs.ParamDataStructures.AbstractSnapshots, GridapROMs.Utils.CostTracker, GridapROMs.Utils.CostTracker}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.eval_performance","text":"eval_performance(\n  solver::RBSolver,\n  feop::ParamOperator,\n  fesnaps::AbstractSnapshots,\n  rbsnaps::AbstractSnapshots,\n  festats::CostTracker,\n  rbstats::CostTracker\n  ) -> ROMPerformance\n\nArguments:\n\nsolver: solver for the reduced problem\nfeop: FE operator representing the PDE\nfesnaps: online snapshots of the FE solution\nrbsnaps: reduced approximation of fesnaps\nfestats: time and memory consumption needed to compute fesnaps\nrbstats: time and memory consumption needed to compute rbsnaps\n\nReturns the performance of the reduced algorithm, in terms of the (relative) error between rbsnaps and fesnaps, and the computational speedup between rbstats and festats\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.galerkin_projection-Tuple{AbstractMatrix, AbstractMatrix}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.galerkin_projection","text":"galerkin_projection(Φₗ,A) -> Any\ngalerkin_projection(Φₗ,A,Φᵣ) -> Any\n\nGalerkin projection of A on the subspaces specified by a (left, test) subspace Φₗ (row projection) and a (right, trial) subspace Φᵣ (column projection)\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.galerkin_projection-Tuple{Projection, Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.galerkin_projection","text":"galerkin_projection(a::Projection,b::Projection) -> ReducedProjection\ngalerkin_projection(a::Projection,b::Projection,c::Projection,args...) -> ReducedProjection\n\n(Petrov) Galerkin projection of a projection map b onto the subspace a (row projection) and, if applicable, onto the subspace c (column projection)\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_basis-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_basis","text":"get_basis(a::Projection) -> AbstractMatrix\n\nReturns the basis spanning the reduced subspace represented by the projection a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_fe_solver-Tuple{RBSolver}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_fe_solver","text":"get_fe_solver(s::RBSolver) -> NonlinearSolver\n\nReturns the underlying NonlinearSolver from a RBSolver s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_interpolation-Tuple{GridapROMs.RBSteady.HRProjection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_interpolation","text":"get_interpolation(a::HRProjection) -> Interpolation\n\nFor a HRProjection a represented by the couple (Φrb,i), returns i\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_reduced_subspace-Tuple{RBSpace}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_reduced_subspace","text":"get_reduced_subspace(r::RBSpace) -> Projection\n\nReturns the Projection spanning the reduced subspace contained in r\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_rowcols_to_cells-Tuple{AbstractArray{<:AbstractArray}, AbstractArray{<:AbstractArray}, AbstractVector, AbstractVector}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_rowcols_to_cells","text":"get_rowcols_to_cells(\n  cell_row_ids::AbstractArray{<:AbstractArray},\n  cell_col_ids::AbstractArray{<:AbstractArray},\n  rows::AbstractVector,cols::AbstractVector) -> AbstractVector\n\nReturns the list of cells containing the row ids rows and the col ids cols\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_rows_to_cells-Tuple{AbstractArray{<:AbstractArray}, AbstractVector}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_rows_to_cells","text":"get_rows_to_cells(\n  cell_row_ids::AbstractArray{<:AbstractArray},\n  rows::AbstractVector\n  ) -> AbstractVector\n\nReturns the list of cells containing the row ids rows\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.gram_schmidt","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.gram_schmidt","text":"gram_schmidt(A::AbstractMatrix,args...) -> AbstractMatrix\ngram_schmidt(A::AbstractMatrix,X::AbstractSparseMatrix,args...) -> AbstractMatrix\n\nGram-Schmidt orthogonalization for a matrix A under a Euclidean norm. A (positive definite) sparse matrix X representing an inner product on the row space of A can be provided to make the result orthogonal under a different norm\n\n\n\n\n\n","category":"function"},{"location":"rbsteady/#GridapROMs.RBSteady.inv_project!-Tuple{AbstractArray, Projection, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.inv_project!","text":"inv_project!(x::AbstractArray,a::Projection,x̂::AbstractArray) -> Nothing\n\nIn-place recasting of a low-dimensional object x̂ the high-dimensional space in which a is immersed\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.inv_project-Tuple{Projection, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.inv_project","text":"inv_project(a::Projection,x::AbstractArray) -> AbstractArray\n\nRecasts a low-dimensional object x onto the high-dimensional space in which a is immersed\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.jacobian_snapshots-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.jacobian_snapshots","text":"jacobian_snapshots(solver::RBSolver,op::ParamOperator,s::AbstractSnapshots) -> Contribution\njacobian_snapshots(solver::RBSolver,op::ODEParamOperator,s::AbstractSnapshots) -> Tuple{Vararg{Contribution}}\n\nReturns a Jacobian Contribution relative to the FE operator op. The quantity s denotes the solution snapshots in which we evaluate the jacobian. In transient settings, the output is a tuple whose nth element is the Jacobian relative to the nth temporal derivative\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_contribution-Tuple{Any, Tuple{Vararg{Gridap.Geometry.Triangulation}}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_contribution","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_operator-Tuple{Any, ParamOperator}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_operator","text":"load_operator(dir,feop::ParamOperator;kwargs...) -> RBOperator\n\nGiven a FE operator feop, load its reduced counterpart stored in the directory dir. Throws an error if the reduced operator has not been previously saved to file\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_reduced_subspace-Tuple{Any, Gridap.FESpaces.FESpace}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_reduced_subspace","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_results-Tuple{Any}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_results","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_snapshots-Tuple{Any}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_snapshots","text":"load_snapshots(dir;label=\"\") -> AbstractSnapshots\n\nLoad the snapshots at the directory dir. Throws an error if the snapshots have not been previously saved to file\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.num_fe_dofs-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.num_fe_dofs","text":"num_fe_dofs(a::Projection) -> Int\n\nFor a projection map a from a low dimensional space n to a high dimensional one N, returns N\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.num_reduced_dofs-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.num_reduced_dofs","text":"num_reduced_dofs(a::Projection) -> Int\n\nFor a projection map a from a low dimensional space n to a high dimensional one N, returns n\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.orth_complement!-Tuple{AbstractVector, AbstractMatrix, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.orth_complement!","text":"orth_complement!(v::AbstractVector,basis::AbstractMatrix,args...) -> Nothing\n\nIn-place orthogonal complement of v on the column space of basis. When a symmetric, positive definite matrix X is provided as an argument, the output is X-orthogonal, otherwise it is ℓ²-orthogonal\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.orth_projection-Tuple{AbstractVector, AbstractMatrix}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.orth_projection","text":"orth_projection(v::AbstractVector, basis::AbstractMatrix, args...) -> AbstractVector\n\nOrthogonal projection of v on the column space of basis. When a symmetric, positive definite matrix X is provided as an argument, the output is X-orthogonal, otherwise it is ℓ²-orthogonal\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.plot_a_solution-Tuple{String, ParamOperator, Snapshots, Snapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.plot_a_solution","text":"plot_a_solution(\n  dir::String,\n  feop::ParamOperator,\n  sol::AbstractSnapshots,\n  sol_approx::AbstractSnapshots,\n  args...;\n  kwargs...\n  ) -> Nothing\n\nPlots a single FE solution, RB solution, and the point-wise error between the two, by selecting the first FE snapshot in sol and the first reduced snapshot in sol_approx\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.project!-Tuple{AbstractArray, Projection, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.project!","text":"project!(x̂::AbstractArray,a::Projection,x::AbstractArray,args...) -> Nothing\n\nIn-place projection of a high-dimensional object x onto the subspace represented by a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.project-Tuple{Projection, AbstractArray, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.project","text":"project(a::Projection,x::AbstractArray,args...) -> AbstractArray\n\nProjects a high-dimensional object x onto the subspace represented by a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.projection_eltype-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.projection_eltype","text":"projection_eltype(a::Projection) -> DataType\n\nReturns the eltype of the projection a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_basis-Tuple{Reduction, GridapROMs.ParamDataStructures.AbstractSnapshots, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_basis","text":"reduced_basis(red::Reduction,s::AbstractSnapshots,args...) -> Projection\n\nComputes the basis by compressing the snapshots s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_jacobian-Tuple{RBSolver, ParamOperator, RBSpace, RBSpace, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_jacobian","text":"reduced_jacobian(\n  solver::RBSolver,\n  op::ParamOperator,\n  red_trial::RBSpace,\n  red_test::RBSpace,\n  s::AbstractSnapshots\n  ) -> Union{AffineContribution,TupOfAffineContribution}\n\nReduces the Jacobian contained in op via hyper-reduction. This function first builds the Jacobian snapshots, which are then reduced according to the strategy reduced_jacobian specified in the reduced solver solver. In transient applications, the output is a tuple of length equal to the number of Jacobians(i.e., equal to the order of the ODE plus one)\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_operator-Tuple{String, RBSolver, ParamOperator, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_operator","text":"reduced_operator(solver::RBSolver,feop::ParamOperator,args...;kwargs...) -> RBOperator\nreduced_operator(solver::RBSolver,feop::TransientParamOperator,args...;kwargs...) -> TransientRBOperator\n\nComputes a RB operator from the FE operator feop\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_residual-Tuple{RBSolver, ParamOperator, RBSpace, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_residual","text":"reduced_residual(\n  solver::RBSolver,\n  op::ParamOperator,\n  red_test::RBSpace,\n  s::AbstractSnapshots\n  ) -> AffineContribution\n\nReduces the residual contained in op via hyper-reduction. This function first builds the residual snapshots, which are then reduced according to the strategy residual_reduction specified in the reduced solver solver\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_spaces-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_spaces","text":"reduced_spaces(solver::RBSolver,feop::ParamOperator,s::AbstractSnapshots\n  ) -> (RBSpace, RBSpace)\n\nComputes the subspace of the test, trial FESpaces contained in the FE operator feop by compressing the snapshots s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_subspace-Tuple{Gridap.FESpaces.FESpace, Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_subspace","text":"reduced_subspace(space::FESpace,basis::Projection) -> RBSpace\n\nGeneric constructor of a RBSpace from a FESpace space and a projection basis\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_triangulation-Tuple{Gridap.Geometry.Triangulation, GridapROMs.RBSteady.HRProjection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_triangulation","text":"reduced_triangulation(trian::Triangulation,a::HRProjection)\n\nReturns the triangulation view of trian on the integration cells contained in a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_weak_form-Tuple{RBSolver, ParamOperator, RBSpace, RBSpace, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_weak_form","text":"reduced_weak_form(\n  solver::RBSolver,\n  op::ParamOperator,\n  red_trial::RBSpace,\n  red_test::RBSpace,\n  s::AbstractSnapshots\n  ) -> (AffineContribution,Union{AffineContribution,TupOfAffineContribution})\n\nReduces the residual/Jacobian contained in op via hyper-reduction. Check the functions reduced_residual and reduced_jacobian for more details\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduction-Tuple{Reduction, AbstractArray, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduction","text":"reduction(red::Reduction,A::AbstractArray,args...) -> AbstractArray\nreduction(red::Reduction,A::AbstractArray,X::AbstractSparseMatrix) -> AbstractArray\n\nGiven an array (of snapshots) A, returns a reduced basis obtained by means of the reduction strategy red\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.residual_snapshots-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.residual_snapshots","text":"residual_snapshots(solver::RBSolver,op::ParamOperator,s::AbstractSnapshots) -> Contribution\nresidual_snapshots(solver::RBSolver,op::ODEParamOperator,s::AbstractSnapshots) -> Contribution\n\nReturns a residual Contribution relative to the FE operator op. The quantity s denotes the solution snapshots in which we evaluate the residual\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.s_opt-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.s_opt","text":"s_opt(a::Projection) -> (AbstractVector,AbstractMatrix)\n\nComputes the S-OPT hyper-reduction of a. Check this reference for more information\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.sequential_product-Tuple{Vararg{AbstractArray}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.sequential_product","text":"sequential_product(a::AbstractArray,b::AbstractArray...) -> AbstractArray\n\nThis function sequentially multiplies the results of several (sequential as well) calls to contraction\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.solution_snapshots-Tuple{RBSolver, ParamOperator, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.solution_snapshots","text":"solution_snapshots(solver::NonlinearSolver,feop::ParamOperator,r::Realization) -> SteadySnapshots\nsolution_snapshots(solver::ODESolver,feop::TransientParamOperator,r::TransientRealization,u0) -> TransientSnapshots\n\nThe problem encoded in the FE operator feop is solved several times, and the solution snapshots are returned along with the information related to the computational cost of the FE method. In transient settings, an initial condition u0 should be provided.\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.tpod-Tuple{GridapROMs.RBSteady.ReductionStyle, AbstractMatrix, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.tpod","text":"tpod(red_style::ReductionStyle,A::AbstractMatrix) -> AbstractMatrix\ntpod(red_style::ReductionStyle,A::AbstractMatrix,X::AbstractSparseMatrix) -> AbstractMatrix\n\nTruncated proper orthogonal decomposition of A. When provided, X is a (symmetric, positive definite) norm matrix with respect to which the output is made orthogonal. If X is not provided, the output is orthogonal with respect to the euclidean norm\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.ttsvd-Union{Tuple{N}, Tuple{T}, Tuple{GridapROMs.RBSteady.TTSVDRanks, AbstractArray{T, N}}} where {T, N}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ttsvd","text":"ttsvd(red_style::TTSVDRanks,A::AbstractArray) -> AbstractVector{<:AbstractArray}\nttsvd(red_style::TTSVDRanks,A::AbstractArray,X::AbstractRankTensor) -> AbstractVector{<:AbstractArray}\n\nTensor train SVD of A. When provided, X is a norm tensor (representing a symmetric, positive definite matrix) with respect to which the output is made orthogonal. Note: if ndims(A) = N, the length of the ouptput is N-1, since we are not interested in reducing the axis of the parameters. Check this reference for more details\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.union_bases-Tuple{Projection, Projection, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.union_bases","text":"union_bases(a::Projection,b::Projection,args...) -> Projection\n\nComputes the projection corresponding to the union of a and b. In essence this operation performs as\n\ngram_schmidt(union(get_basis(a),get_basis(b)))\n\n\n\n\n\n","category":"method"},{"location":"distributed/#GridapROMs.Distributed","page":"GridapROMs.Distributed","title":"GridapROMs.Distributed","text":"","category":"section"},{"location":"distributed/#GridapROMs.Distributed.GenericPArray","page":"GridapROMs.Distributed","title":"GridapROMs.Distributed.GenericPArray","text":"struct GenericPArray{V,A,B,C,D,T,N} <: AbstractArray{T,N}\n  array_partition::A\n  index_partition::B\n  unpartitioned_axes::C\n  cache::D\nend\n\nSame as PVector, but while the latter always stores a vector with entries partitioned on different cores, this structure stores an array (not necessarily a vector) partitioned along the first dimension (row-wise)\n\n\n\n\n\n","category":"type"},{"location":"distributed/#GridapROMs.Distributed.GenericPArray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{<:AbstractArray{T, N}}, Any}, Tuple{AbstractArray{<:AbstractArray{T, N}}, Any, Any}, Tuple{AbstractArray{<:AbstractArray{T, N}}, Any, Any, Any}} where {T, N}","page":"GridapROMs.Distributed","title":"GridapROMs.Distributed.GenericPArray","text":"GenericPArray(array_partition,index_partition)\n\nCreate an instance of GenericPArray from the underlying properties array_partition and index_partition.\n\n\n\n\n\n","category":"method"},{"location":"distributed/#GridapROMs.Distributed.OwnAndGhostParamVectors","page":"GridapROMs.Distributed","title":"GridapROMs.Distributed.OwnAndGhostParamVectors","text":"struct OwnAndGhostParamVectors{A,B,T} <: AbstractParamVector{T}\n  own_values::A\n  ghost_values::A\n  permutation::B\nend\n\nParametric version of OwnAndGhostVectors\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamFESpaces","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces","text":"","category":"section"},{"location":"param_geometry/#GridapROMs.ParamGeometry.DisplacementMap","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.DisplacementMap","text":"struct DisplacementMap <: GridMapStyle end\n\nTrait for displacement maps d: Ω ↦ (I+d)∘Ω, with I being the identity; here, each coordinate x of Ω is mapped to x + d(x). Note: d may be parameterized (see AbstractParamFunction)\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.GridMapStyle","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.GridMapStyle","text":"abstract type GridMapStyle end\n\nAbstraction for maps used to modify a Grid in Gridap. Subtypes:\n\nPhysicalMap\nDisplacementMap\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.ParamGrid","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.ParamGrid","text":"abstract type ParamGrid{Dc,Dp} <: Grid{Dc,Dp} end\n\nAbstraction for mapped grids, whenever the map is parameterized. Subtypes:\n\nParamMappedGrid\nParamUnstructuredGrid\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.ParamMappedDiscreteModel","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.ParamMappedDiscreteModel","text":"struct ParamMappedDiscreteModel{Dc,Dp} <: DiscreteModel{Dc,Dp}\n  model::DiscreteModel{Dc,Dp}\n  mapped_grid::ParamMappedGrid{Dc,Dp}\nend\n\nRepresents a model with a ParamMappedGrid grid. See also MappedDiscreteModel in Gridap.\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.ParamMappedGrid","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.ParamMappedGrid","text":"struct ParamMappedGrid{Dc,Dp,A} <: ParamGrid{Dc,Dp}\n  grid::Grid{Dc,Dp}\n  node_coords::A\nend\n\nStandard implementation of a ParamGrid. The field grid represents a Grid in a reference configuration, while node_coords is a structure collecting the mapped coordinates\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.ParamSubCellTriangulation","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.ParamSubCellTriangulation","text":"struct ParamSubCellTriangulation{Dc,Dp,T,A} <: Triangulation{Dc,Dp}\n  subcells::ParamSubCellData{Dc,Dp,T}\n  bgmodel::A\n  subgrid::ParamUnstructuredGrid{Dc,Dp,T,NonOriented,Nothing}\nend\n\nParameterized version of a SubCellTriangulation in GridapEmbedded\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.ParamSubFacetTriangulation","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.ParamSubFacetTriangulation","text":"struct ParamSubFacetTriangulation{Dc,Dp,T,A} <: Triangulation{Dc,Dp}\n  subfacets::ParamSubFacetData{Dp,T}\n  bgmodel::A\n  subgrid::ParamUnstructuredGrid{Dc,Dp,T,NonOriented,Nothing}\nend\n\nParameterized version of a SubFacetTriangulation in GridapEmbedded\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.ParamUnstructuredGrid","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.ParamUnstructuredGrid","text":"struct ParamUnstructuredGrid{Dc,Dp,Tp,O,Tn} <: ParamGrid{Dc,Dp}\n  node_coordinates::ParamBlock{Vector{Point{Dp,Tp}}}\n  cell_node_ids::Table{Int32,Vector{Int32},Vector{Int32}}\n  reffes::Vector{LagrangianRefFE{Dc}}\n  cell_types::Vector{Int8}\n  orientation_style::O\n  facet_normal::Tn\n  cell_map\nend\n\nParameterized version of a Gridap UnstructuredGrid. Note: this struct could be avoided in future versions, by simply generalizing the type of the node_coordinates field in UnstructuredGrids.\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.PhysicalMap","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.PhysicalMap","text":"struct PhysicalMap <: GridMapStyle end\n\nTrait for standard physical maps φ: Ω ↦ φ∘Ω, i.e. each coordinate x of Ω is mapped to φ(x). Note: φ may be parameterized (see AbstractParamFunction)\n\n\n\n\n\n","category":"type"},{"location":"param_geometry/#GridapROMs.ParamGeometry.mapped_grid-Tuple{GridapROMs.ParamGeometry.GridMapStyle, Gridap.Geometry.Grid, AbstractVector}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamGeometry.mapped_grid","text":"mapped_grid(style::GridMapStyle,grid::Grid,f) -> Grid\n\nReturns a Grid by applying the map f on a reference configuration grid, according to the strategy provided by style\n\n\n\n\n\n","category":"method"},{"location":"param_odes/#GridapROMs.ParamODEs","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs","text":"","category":"section"},{"location":"param_odes/#GridapROMs.ParamODEs.JointODEParamOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.JointODEParamOperator","text":"const JointODEParamOperator{O<:ODEParamOperatorType} = ODEParamOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.JointTransientParamFEOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.JointTransientParamFEOperator","text":"const JointTransientParamFEOperator{O<:ODEParamOperatorType} = TransientParamFEOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.LinearNonlinearParamODE","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.LinearNonlinearParamODE","text":"struct LinearNonlinearParamODE <: ODEParamOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.LinearParamODE","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.LinearParamODE","text":"struct LinearParamODE <: ODEParamOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.NonlinearParamODE","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.NonlinearParamODE","text":"struct NonlinearParamODE <: ODEParamOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ODEParamOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ODEParamOperator","text":"const ODEParamOperator{T<:ODEParamOperatorType,T<:TriangulationStyle} = ParamOperator{O,T}\n\nTransient extension of the type ParamOperator.\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ODEParamOperatorType","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ODEParamOperatorType","text":"abstract type ODEParamOperatorType <: UnEvalOperatorType end\n\nParametric extension of the type ODEOperatorType in Gridap.\n\nSubtypes:\n\nNonlinearParamODE\nLinearParamODE\nLinearNonlinearParamODE\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ODEParamSolution","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ODEParamSolution","text":"struct ODEParamSolution{V} <: ODESolution\n  solver::ODESolver\n  odeop::ODEParamOperator\n  r::TransientRealization\n  us0::Tuple{Vararg{V}}\nend\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ParamStageOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ParamStageOperator","text":"struct ParamStageOperator{O} <: NonlinearParamOperator\n  op::ODEParamOperator{O}\n  r::TransientRealization\n  state_update::Function\n  ws::Tuple{Vararg{Real}}\n  paramcache::AbstractParamCache\nend\n\nStage operator to solve a parametric ODE with a time marching scheme\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.SplitODEParamOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.SplitODEParamOperator","text":"const SplitODEParamOperator{O<:ODEParamOperatorType} = ODEParamOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.SplitTransientParamFEOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.SplitTransientParamFEOperator","text":"const SplitTransientParamFEOperator{O<:ODEParamOperatorType} = TransientParamFEOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientLinearParamFEOpFromWeakForm","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientLinearParamFEOpFromWeakForm","text":"struct TransientLinearParamFEOpFromWeakForm{T} <: TransientParamFEOperator{LinearParamODE,T}\n  res::Function\n  jacs::Tuple{Vararg{Function}}\n  constant_forms::Tuple{Vararg{Bool}}\n  tpspace::TransientParamSpace\n  assem::Assembler\n  trial::FESpace\n  test::FESpace\n  domains::FEDomains\n  order::Integer\nend\n\nInstance of TransientParamFEOperator, to be used when the transient problem is linear\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientMultiFieldParamFESpace","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientMultiFieldParamFESpace","text":"const TransientMultiFieldParamFESpace = MultiFieldFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamFEOpFromWeakForm","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamFEOpFromWeakForm","text":"struct TransientParamFEOpFromWeakForm{T} <: TransientParamFEOperator{NonlinearParamODE,T}\n  res::Function\n  jacs::Tuple{Vararg{Function}}\n  tpspace::TransientParamSpace\n  assem::Assembler\n  trial::FESpace\n  test::FESpace\n  domains::FEDomains\n  order::Integer\nend\n\nInstance of TransientParamFEOperator, to be used when the transient problem is nonlinear\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamFEOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamFEOperator","text":"const TransientParamFEOperator{O<:ODEParamOperatorType,T<:TriangulationStyle} = ParamFEOperator{O,T}\n\nParametric extension of a TransientFEOperator in Gridap. Compared to a standard TransientFEOperator, there are the following novelties:\n\na TransientParamSpace is provided, so that parametric realizations can be extracted directly from the TransientParamFEOperator\na function representing a norm matrix is provided, so that errors in the desired norm can be automatically computed\n\nSubtypes:\n\nTransientParamFEOpFromWeakForm\nTransientLinearParamFEOpFromWeakForm\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamFESolution","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamFESolution","text":"struct TransientParamFESolution{V} <: TransientFESolution\n  odesol::ODEParamSolution{V}\n  trial\nend\n\nWrapper around a TransientParamFEOperator and ODESolver that represents the parametric solution at a set of time steps. It is an iterator that computes the solution at each time step in a lazy fashion when accessing the solution.\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientTrialParamFESpace","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientTrialParamFESpace","text":"const TransientTrialParamFESpace = UnEvalTrialFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientLinearParamFEOperator-Tuple{Function, Tuple{Vararg{Function}}, Any, Any, Any}","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientLinearParamFEOperator","text":"TransientLinearParamFEOperator(res::Function,forms::Tuple{Vararg{Function}},     tpspace,trial,test;kwargs...) -> TransientLinearParamFEOpFromWeakForm{TriangulationStyle}\n\nReturns a linear parametric FE operator\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps","text":"","category":"section"},{"location":"dof_maps/#GridapROMs.DofMaps.AbstractDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.AbstractDofMap","text":"abstract type AbstractDofMap{D,Ti} <: AbstractArray{Ti,D} end\n\nType representing an indexing strategy for FE quantitites (e.g. FE vectors such as FE solutions and residuals, or FE sparse matrices such as FE Jacobians). Subtypes:\n\nInverseDofMap\nVectorDofMap\nTrivialSparseMatrixDofMap\nSparseMatrixDofMap\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.DofMapArray","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.DofMapArray","text":"struct DofMapArray{T,D,Ti,A<:AbstractArray{T},I<:AbstractArray{Ti,D}} <: AbstractArray{T,D}\n  array::A\n  dof_map::I\nend\n\nSubtype of AbstractArray whose entries stored in array are indexed according to the indexing strategy specified in dof_map\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.DofsToODofs","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.DofsToODofs","text":"struct DofsToODofs{D,P,V} <: Map\n  b::LagrangianDofBasis{P,V}\n  odof_to_dof::Vector{Int8}\n  node_and_comps_to_odof::Array{V,D}\n  orders::NTuple{D,Int}\nend\n\nMap used to convert a DOF of a standard FESpace in Gridap to a DOF belonging to a space whose DOFs are lexicographically-ordered\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.InverseDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.InverseDofMap","text":"struct InverseDofMap{D,Ti,I<:AbstractDofMap{D,Ti}} <: AbstractDofMap{D,Ti}\n  dof_map::I\nend\n\nInverse dof map of a given AbstractDofMap object dof_map\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OIdsToIds","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OIdsToIds","text":"struct OIdsToIds{T,S} <: AbstractVector{T}\n  indices::Vector{T}\n  terms::Vector{S}\nend\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OReindex","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OReindex","text":"struct OReindex <: Map end\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OrderedFESpace","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OrderedFESpace","text":"struct OrderedFESpace{S<:SingleFieldFESpace} <: SingleFieldFESpace\n  space::S\n  cell_odofs_ids::AbstractArray\n  fe_odof_basis::CellDof\n  dirichlet_odof_tag::Vector{Int8}\nend\n\nInterface for FE spaces whose DOFs are ordered lexycographically. Notes:\n\nThere are two separate lexycographies for free and Dirichlet DOFs, as in standard Gridap FE spaces: positive ids correspond to free DOFs, negative ids correspond to Dirichlet DOFs\nThe following lexycographical hierarchy is considered: x-axis, y-axis, z-axis, component axis (only for multi-valued problems)\nAn exception of the ordering is given by the function scatterfreeanddirichletvalues, which returns the scattered (cell) values in the standard Gridap ordering, in order to prevent errors when comparing two FEFunctions defined on a standard FE space or an ordered FE space. This feature can be removed with some work in future versions\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.Range1D","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.Range1D","text":"struct Range1D{I<:AbstractVector,J<:AbstractVector} <: AbstractVector{Int}\n  range::Range2D{I,J}\nend\n\nRepresents a Range2D reshaped as a vector\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.Range2D","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.Range2D","text":"struct Range2D{I<:AbstractVector,J<:AbstractVector} <: AbstractMatrix{Int}\n  axis1::I\n  axis2::J\n  scale::Int\nend\n\nCreates the indices of a Kronecker product matrix from the indices of the two factors. The field axis1 refers to the first factor, field axis2 refers to the second factor. The field scale is by default equal to the number of entries of the first factor.\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.SparseMatrixDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.SparseMatrixDofMap","text":"struct SparseMatrixDofMap{D,Ti,A<:SparsityPattern} <: AbstractDofMap{D,Ti}\n  d_sparse_dofs_to_sparse_dofs::Array{Ti,D}\n  d_sparse_dofs_to_full_dofs::Array{Ti,D}\n  sparsity::A\nend\n\nIndex map used to select the nonzero entries of a sparse matrix of sparsity sparsity. The nonzero entries are sorted according to the field d_sparse_dofs_to_sparse_dofs by default. For more details, check the function get_d_sparse_dofs_to_full_dofs\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.SparsityCSC","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.SparsityCSC","text":"struct SparsityCSC{Tv,Ti} <: SparsityPattern\n  matrix::SparseMatrixCSC{Tv,Ti}\nend\n\nSparsity pattern associated to a compressed sparse column matrix matrix\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.SparsityPattern","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.SparsityPattern","text":"abstract type SparsityPattern end\n\nType used to represent the sparsity pattern of a sparse matrix, usually the Jacobian in a FE problem.\n\nSubtypes:\n\nSparsityCSC\nTProductSparsity\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.TProductSparsity","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.TProductSparsity","text":"struct TProductSparsity{A<:SparsityPattern,B<:SparsityPattern} <: SparsityPattern\n  sparsity::A\n  sparsities_1d::Vector{B}\nend\n\nFields:\n\nsparsity: a SparsityPattern of a matrix assembled on a Cartesian geometry of dimension D\nsparsities_1d: a vector of D 1D sparsity patterns\n\nStructure used to represent a SparsityPattern of a matrix obtained by integrating a bilinear form on a triangulation that can be obtained as the tensor product of D 1D triangulations. For example, this can be done on a Cartesian mesh composed of D-cubes\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.TrivialDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.TrivialDofMap","text":"const TrivialDofMap{Ti} = AbstractDofMap{1,Ti}\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.TrivialSparseMatrixDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.TrivialSparseMatrixDofMap","text":"struct TrivialSparseMatrixDofMap{A<:SparsityPattern} <: TrivialDofMap{Int}\n  sparsity::A\nend\n\nIndex map used to select the nonzero entries of a sparse matrix of sparsity sparsity\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.VectorDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.VectorDofMap","text":"struct VectorDofMap{D,I<:AbstractVector{<:Integer}} <: AbstractDofMap{D,Int32}\n  size::Dims{D}\n  bg_dof_to_act_dof::I\nend\n\nDof map intended for the reindexing of FE vectors (e.g. FE solutions or residuals).\n\nFields:\n\nsize: denotes the desired shape of the reindexed array\nbg_dof_to_act_dof: vector mapping a background DOF to an active DOF. A background DOF lives on a FESpace defined on a background Cartesian mesh; an active DOF lives on a FESpace defined on an active mesh, which must occupy a portion of the background mesh. When the active mesh coincides with the background one, bg_dof_to_act_dof represents simply an identity map. If not, this means there are inactive DOFs in the background FESpace, which bg_dof_to_act_dof is responsible of masking.\n\nMore in detail, if size = (n1,...,nD), we can think of this mapping as a function\n\nn1 × ... × nD ⟶ {0,1,...,Nact}\n\nwhere Nact is the number of active DOFs. The output of this map is an index according to which we reindex FE vectors. We follow the convention that, when indexed by zero, the FE vectors return a zero. This is acceptable, since the FE vector does not actually hold a value when indexed at an inactive DOF.\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.add_ordered_entries!-Tuple{Function, Any, Nothing, GridapROMs.DofMaps.OIdsToIds, GridapROMs.DofMaps.OIdsToIds}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.add_ordered_entries!","text":"add_ordered_entries!(combine::Function,A,vs,is::OIdsToIds,js::OIdsToIds)\n\nAdds several ordered entries only for positive input indices. Returns A\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.change_dof_map-Tuple{GridapROMs.DofMaps.AbstractDofMap, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.change_dof_map","text":"change_dof_map(i::AbstractDofMap,args...) -> AbstractDofMap\n\nCreates a new dof map from an old dof map i\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.compose_index-Tuple{Any, Any}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.compose_index","text":"compose_index(i1_to_i2,i2_to_i3) -> AbstractVector\n\nReturns an index map i1_to_i3 representing the composition i1_to_i2 ∘ i2_to_i3\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.fast_index-Tuple{Any, Integer}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.fast_index","text":"fast_index(i,nfast::Integer) -> Any\n\nReturns the fast index in a tensor product structure. Suppose we have two matrices A and B of sizes Ra × Ca and Rb × Rb. Their kronecker product AB = A ⊗ B, of size RaRb × CaCb, can be indexed as\n\nAB[i,j] = A[slow_index(i,RbCb)] * B[fast_index(i,RbCb)],\n\nwhere nfast == RbCb. In other words, this function converts an index belonging to AB to an index belonging to B\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.flatten-Tuple{GridapROMs.DofMaps.AbstractDofMap}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.flatten","text":"flatten(i::AbstractDofMap) -> TrivialDofMap\n\nFlattens i, the output will be a dof map with ndims == 1\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_active_dof_to_bg_dof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_active_dof_to_bg_dof","text":"get_active_dof_to_bg_dof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace\n  ) -> (AbstractVector,AbstractVector)\n\nSame as get_dof_to_bg_dof, unless f is a FESpaceWithLinearConstraints, in which case it calls get_dof_to_bg_dof on the underlying, unconstrained space\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_bg_ddof_to_ddof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_bg_ddof_to_ddof","text":"get_bg_ddof_to_ddof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace) -> AbstractVector\n\nGiven a background FE space bg_f, e.g. defined on a background discrete model, and a FE space f defined on an active portion of such model, defines an index mapping relating each Dirichlet dof of bg_f to a Dirichlet dof in f. In practice, it returns a map v of length bg_nddofs such that v[bg_ddof] = ddof if bg_ddof is located in the active portion, and v[bg_ddof] = 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_bg_dof_to_active_dof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_bg_dof_to_active_dof","text":"get_bg_dof_to_active_dof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace\n  ) -> (AbstractVector,AbstractVector)\n\nSame as get_bg_dof_to_dof, unless f is a FESpaceWithLinearConstraints, in which case it calls get_bg_dof_to_dof on the underlying, unconstrained space\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_bg_dof_to_dof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_bg_dof_to_dof","text":"get_bg_dof_to_dof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace\n  ) -> (AbstractVector,AbstractVector)\n\nGiven a background FE space bg_f, e.g. defined on a background discrete model, and a FE space f defined on an active portion of such model, returns the results of get_bg_fdof_to_fdof and get_bg_ddof_to_ddof\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_bg_fdof_to_fdof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_bg_fdof_to_fdof","text":"get_bg_fdof_to_fdof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace) -> AbstractVector\n\nGiven a background FE space bg_f, e.g. defined on a background discrete model, and a FE space f defined on an active portion of such model, defines an index mapping relating each free dof of bg_f to a free dof in f. In practice, it returns a map v of length bg_nfdofs such that v[bg_fdof] = fdof if bg_fdof is located in the active portion, and v[bg_fdof] = 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_d_sparse_dofs_to_full_dofs-Tuple{Any, Any, GridapROMs.DofMaps.TProductSparsity}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_d_sparse_dofs_to_full_dofs","text":"get_d_sparse_dofs_to_full_dofs(Tu,Tv,a::TProductSparsity) -> AbstractArray{<:Integer,D}\n\nInput:\n\nTu, Tv: DOF types of a trial FESpace U and test FESpace V, respecively\na: a TProductSparsity representing the sparsity of the matrix assembled from U and V\n\nOutput:\n\na D-array d_sparse_dofs_to_full_dofs, which represents a map from Nnz_1 × … × Nnz_{D} to M⋅N, where Nnz_i represents the number of nonzero entries of the ith 1D sparsity contained in a, and M⋅N is the total length of the tensor product sparse matrix in a. For vector-valued FESpaces, an additional axis is added to d_sparse_dofs_to_full_dofs representing the number of components. In particular, the component axis has a length equal to num_components(Tu)⋅num_components(Tv)\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_ddof_to_bg_ddof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_ddof_to_bg_ddof","text":"get_ddof_to_bg_ddof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace) -> AbstractVector\n\nGiven a background FE space bg_f, e.g. defined on a background discrete model, and a FE space f defined on an active portion of such model, defines an index mapping relating each Dirichlet dof of f to a Dirichlet dof in bg_f. In practice, it returns a map v of length nddofs such that v[ddof] = bg_ddof\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_dof_eltype-Tuple{Gridap.FESpaces.FESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_dof_eltype","text":"get_dof_eltype(f::FESpace) -> Type\n\nFetches the DOF eltype for a FESpace f\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_dof_map-Tuple{Gridap.FESpaces.SingleFieldFESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_dof_map","text":"get_dof_map(space::FESpace) -> VectorDofMap\n\nReturns the free dofs sorted by coordinate order, for every dimension. If space is a D-dimensional, scalar FESpace, the output index map will be a subtype of AbstractDofMap{<:Integer,D}. If space is a D-dimensional, vector-valued FESpace, the output index map will be a subtype of AbstractDofMap{D+1}.\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_dof_map_with_diri-Tuple{Gridap.FESpaces.FESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_dof_map_with_diri","text":"get_dof_map_with_diri(space::FESpace) -> VectorDofMap\n\nSame as get_dof_map, but includes also Dirichlet dofs\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_dof_to_bg_dof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_dof_to_bg_dof","text":"get_dof_to_bg_dof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace\n  ) -> (AbstractVector,AbstractVector)\n\nGiven a background FE space bg_f, e.g. defined on a background discrete model, and a FE space f defined on an active portion of such model, returns the results of get_fdof_to_bg_fdof and get_ddof_to_bg_ddof\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_fdof_to_bg_fdof-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_fdof_to_bg_fdof","text":"get_fdof_to_bg_fdof(bg_f::SingleFieldFESpace,f::SingleFieldFESpace) -> AbstractVector\n\nGiven a background FE space bg_f, e.g. defined on a background discrete model, and a FE space f defined on an active portion of such model, defines an index mapping relating each free dof of f to a free dof in bg_f. In practice, it returns a map v of length nfdofs such that v[fdof] = bg_fdof\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_group_to_ilabels-Tuple{AbstractVector}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_group_to_ilabels","text":"get_group_to_ilabels(labels::AbstractVector) -> Table\n\nGiven a vector of natural numbers labels, returns a table of length maximum(labels) - minimum(labels), whose entries group the indices associated with equal entries of labels. An empty group is assigned whenever a label does not appear in labels Example:\n\njulia> labels = [1,3,2,3,1,5,5]\n7-element Vector{Int64}:\n 1\n 3\n 2\n 3\n 1\n 5\n 5\njulia> get_group_to_ilabels(labels)\n5-element Table{Int32, Vector{Int32}, Vector{Int32}}:\n [1, 5]\n [3]\n [2, 4]\n []\n [6, 7]\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_group_to_labels-Tuple{AbstractVector}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_group_to_labels","text":"get_group_to_labels(labels::AbstractVector) -> Table\n\nGiven a vector of natural numbers labels, returns a table of length maximum(labels) - minimum(labels), whose entries group equal entries of labels. An empty group is assigned whenever a label does not appear in labels Example:\n\njulia> labels = [1,3,2,3,1,5,5]\n7-element Vector{Int64}:\n 1\n 3\n 2\n 3\n 1\n 5\n 5\njulia> get_group_to_labels(labels)\n5-element Table{Int32, Vector{Int32}, Vector{Int32}}:\n [1, 1]\n [2]\n [3, 3]\n []\n [5, 5]\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_sparse_dof_map-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_sparse_dof_map","text":"get_sparse_dof_map(trial::FESpace,test::FESpace,args...) -> AbstractDofMap\n\nReturns the index maps related to Jacobiansin a FE problem. The default output is a TrivialSparseMatrixDofMap; when the trial and test spaces are of type TProductFESpace, a SparseMatrixDofMap is returned.\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_sparsity","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_sparsity","text":"get_sparsity(U::FESpace,V::FESpace,trian=_get_common_domain(U,V)) -> SparsityPattern\n\nBuilds a SparsityPattern from two FESpaces U and V, via integration on a triangulation trian\n\n\n\n\n\n","category":"function"},{"location":"dof_maps/#GridapROMs.DofMaps.group_ilabels-Tuple{AbstractVector}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.group_ilabels","text":"group_ilabels(labels::AbstractVector) -> Table\n\nSame as get_group_to_ilabels, but removes the empty groups corresponding to non-existing labels in labels Example:\n\njulia> labels = [1,3,2,3,1,5,5]\n7-element Vector{Int64}:\n 1\n 3\n 2\n 3\n 1\n 5\n 5\njulia> group_ilabels(labels)\n4-element Table{Int32, Vector{Int32}, Vector{Int32}}:\n [1, 5]\n [3]\n [2, 4]\n [6, 7]\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.group_labels-Tuple{AbstractVector}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.group_labels","text":"group_labels(labels::AbstractVector) -> Table\n\nSame as get_group_to_labels, but removes the empty groups corresponding to non-existing labels in labels Example:\n\njulia> labels = [1,3,2,3,1,5,5]\n7-element Vector{Int64}:\n 1\n 3\n 2\n 3\n 1\n 5\n 5\njulia> group_labels(labels)\n4-element Table{Int32, Vector{Int32}, Vector{Int32}}:\n [1, 1]\n [2]\n [3, 3]\n [5, 5]\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.inverse_table-Tuple{Gridap.Arrays.Table}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.inverse_table","text":"inverse_table(a_to_b::Table) -> Table\n\nGiven the input table a_to_b, returns the inverse table b_to_a Example:\n\njulia> a = Table([[1,2,3],[2,3,4]])\n2-element Table{Int64, Vector{Int64}, Vector{Int32}}:\n [1, 2, 3]\n [2, 3, 4]\njulia> inverse_table(a)\n4-element Table{Int32, Vector{Int32}, Vector{Int32}}:\n [1]\n [1, 2]\n [1, 2]\n [2]\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.invert-Tuple{GridapROMs.DofMaps.AbstractDofMap}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.invert","text":"invert(i::AbstractDofMap) -> InverseDofMap\n\nRetruns an InverseDofMap object out of an existing dof map i\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.range_1d-Tuple{AbstractVector, AbstractVector, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.range_1d","text":"range_1d(i::AbstractVector,j::AbstractVector,args...) -> AbstractVector{Int}\n\nVectorization operation of a Range2D object\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.range_2d","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.range_2d","text":"range_2d(i::AbstractVector,j::AbstractVector,scale=length(i)) -> Range2D\n\nConstructor of a Range2D object\n\n\n\n\n\n","category":"function"},{"location":"dof_maps/#GridapROMs.DofMaps.recast-Tuple{AbstractArray, AbstractArray}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.recast","text":"recast(v::AbstractVector,a::AbstractSparseMatrix) -> AbstractSparseMatrix\n\nReturns a sparse matrix with values equal to v, and sparsity pattern equal to that of a\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.recast_indices-Tuple{AbstractArray, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.recast_indices","text":"recast_indices(fids::AbstractArray,a::AbstractSparseMatrix) -> AbstractArray\n\nInput:\n\na sparse matrix a of size (M,N) and a number of nonzero entries Nnz\nan array of indices sids with values ∈ {1,...,Nnz} (sparse indices)\n\nOutput:\n\nan array of indices fids with values ∈ {1,...,MN} (full indices), whose\n\nentries are associated to those of sids. Zero entries are preserved\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.recast_split_indices-Tuple{AbstractArray, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.recast_split_indices","text":"recast_split_indices(fids::AbstractArray,a::AbstractSparseMatrix) -> (AbstractArray,AbstractArray)\n\nInput:\n\na sparse matrix a of size (M,N) and a number of nonzero entries Nnz\nan array of indices sids with values ∈ {1,...,Nnz} (sparse indices)\n\nOutput:\n\nan array rows of indices frows with values ∈ {1,...,M} (full rows), whose\n\nentries are associated to those of sids. Zero entries are preserved\n\nan array rows of indices fcols with values ∈ {1,...,N} (full cols), whose\n\nentries are associated to those of sids. Zero entries are preserved\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.slow_index-Tuple{Any, Integer}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.slow_index","text":"slow_index(i,nfast::Integer) -> Any\n\nReturns the slow index in a tensor product structure. Suppose we have two matrices A and B of sizes Ra × Ca and Rb × Rb. Their kronecker product AB = A ⊗ B, of size RaRb × CaCb, can be indexed as\n\nAB[i,j] = A[slow_index(i,RbCb)]B[fast_index(i,RbCb)],\n\nwhere nfast == RbCb. In other words, this function converts an index belonging to AB to an index belonging to A\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.sparsify_indices-Tuple{AbstractArray, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.sparsify_indices","text":"sparsify_indices(sids::AbstractArray,a::AbstractSparseMatrix) -> AbstractArray\n\nInput:\n\na sparse matrix a of size (M,N) and a number of nonzero entries Nnz\nan array of indices fids with values ∈ {1,...,MN} (full indices)\n\nOutput:\n\nan array of indices sids with values ∈ {1,...,Nnz} (sparse indices), whose\n\nentries are associated to those of fids. Zero entries are preserved\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.vectorize-Tuple{GridapROMs.DofMaps.AbstractDofMap}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.vectorize","text":"vectorize(i::AbstractDofMap) -> AbstractVector\n\nReshapes i as a vector, and removes the masked dofs in i (if any)\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces","text":"","category":"section"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.MultiFieldParamFEFunction","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.MultiFieldParamFEFunction","text":"struct MultiFieldParamFEFunction{T<:MultiFieldCellField} <: ParamFEFunction\n  single_fe_functions::Vector{<:SingleFieldParamFEFunction}\n  free_values::AbstractArray\n  fe_space::MultiFieldFESpace\n  multi_cell_field::T\nend\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.MultiFieldParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.MultiFieldParamFESpace","text":"const MultiFieldParamFESpace = MultiFieldFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.ParamFEFunction","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.ParamFEFunction","text":"abstract type ParamFEFunction <: FEFunction end\n\nParametric extension of a FEFunction in Gridap. Subtypes:\n\nSingleFieldParamFEFunction\nMultiFieldParamFEFunction\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.ParamTrialFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.ParamTrialFESpace","text":"const ParamTrialFESpace = UnEvalTrialFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.SingleFieldParamFEFunction","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.SingleFieldParamFEFunction","text":"struct SingleFieldParamFEFunction{T<:CellField} <: ParamFEFunction\n  cell_field::T\n  cell_dof_values::AbstractArray{<:ParamBlock}\n  free_values::AbstractParamVector{<:Number}\n  dirichlet_values::AbstractParamVector{<:Number}\n  fe_space::SingleFieldFESpace\nend\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.SingleFieldParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.SingleFieldParamFESpace","text":"abstract type SingleFieldParamFESpace{S} <: SingleFieldFESpace end\n\nParametric extension of a SingleFieldFESpace in Gridap. The FE spaces inhereting are (trial) spaces on which we can easily define a ParamFEFunction.\n\nSubtypes:\n\nTrivialParamFESpace\nTrialParamFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.TrialParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.TrialParamFESpace","text":"TrialParamFESpace{S} <: SingleFieldParamFESpace{S}\n\nTrial FE space equipped with parametric dirichlet values\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.TrivialParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.TrivialParamFESpace","text":"TrivialParamFESpace{S} <: SingleFieldParamFESpace{S}\n\nWrapper for non-parametric FE spaces that we wish assumed a parametric length\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.UnEvalTrialFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.UnEvalTrialFESpace","text":"struct UnEvalTrialFESpace{A,B} <: SingleFieldFESpace\n  space::A\n  space0::B\n  dirichlet::Union{Function,AbstractVector{<:Function}}\nend\n\nStruct representing trial FE spaces that are not evaluated yet. This may include FE spaces representing transient problems (although the implementation in Gridap, called TransientTrialFESpace, does not fall into this category), parametric problems, and transient-parametric problems.\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamDataStructures.parameterize-Tuple{Gridap.FESpaces.SparseMatrixAssembler, Int64}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamDataStructures.parameterize","text":"parameterize(a::SparseMatrixAssembler,plength::Int) -> SparseMatrixAssembler\n\nReturns an assembler that also stores the parametric length of r. This function is to be used to assemble parametric residuals and Jacobians. The assembly routines follow the same pipeline as in Gridap\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.HomogeneousTrialParamFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, Int64}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.HomogeneousTrialParamFESpace","text":"HomogeneousTrialParamFESpace(U::SingleFieldFESpace,plength::Int) -> TrialParamFESpace\n\nReturns a TrialParamFESpace equipped with homogeneous parametric dirichlet values\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.TrialParamFESpace!-Tuple{GridapROMs.ParamDataStructures.AbstractParamVector{T} where T, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.TrialParamFESpace!","text":"TrialParamFESpace!(dir_values::AbstractParamVector,space::SingleFieldFESpace,objects\n  ) -> TrialParamFESpace\n\nAllows do-block syntax for the construction of a TrialParamFESpace\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.get_vector_type2-Tuple{Gridap.FESpaces.FESpace}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.get_vector_type2","text":"get_vector_type2(f::SingleFieldParamFESpace) -> Type\n\nReturns the vector type of the underlying un-parametric FESpace contained in f\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.param_zero_dirichlet_values","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.param_zero_dirichlet_values","text":"param_zero_dirichlet_values(f::FESpace,L::Integer=param_length(f)) -> AbstractParamVector\n\nParametric version of the function zero_dirichlet_values in Gridap\n\n\n\n\n\n","category":"function"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.param_zero_free_values","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.param_zero_free_values","text":"param_zero_free_values(f::FESpace,L::Integer=param_length(f)) -> AbstractParamVector\n\nParametric version of the function zero_free_values in Gridap\n\n\n\n\n\n","category":"function"},{"location":"#GridapROMs.jl","page":"Home","title":"GridapROMs.jl","text":"Welcome to the documentation for GridapROMs. \n\nnote: Note\nThe documentation is currently under construction.","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"This package provides a set of tools for the solution of parameterized partial differential equations (PDEs) with reduced order models (ROMs). The presence of parameters severely impacts the feasibility of running high-fidelity (HF) codes such as the finite element (FE) method, because typically the solution is required for many different values of the parameters. ROMs create surrogate models that approximate the solution manifold on a lower-dimensional manifold. (In linear ROMs, the manifold is a vector subspace, but more general nonlinear ROMs may be considered.) These surrogates provide accurate solutions in a much shorter time and with much fewer computational resources. Momentarily, the library supports the serial resolution of steady, transient, linear, nonlinear, single- and multi-field parameterized PDEs with the use of linear ROMs. ","category":"section"},{"location":"#Future-work","page":"Home","title":"Future work","text":"We envision two main developments for the library. Firstly, the development of a scalable, distributed-in-memory interface. Secondly, the extension to nonlinear ROMs, for example models with an autoencoder-like structure, which have alredy been proven to be effective in the literature.","category":"section"},{"location":"#Manual","page":"Home","title":"Manual","text":"Pages = [\n  \"utils.md\",\n  \"dof_maps.md\",\n  \"tproduct.md\",\n  \"param_data_structures.md\",\n  \"param_geometry.md\",\n  \"param_fe_spaces.md\",\n  \"param_steady.md\",\n  \"param_odes.md\",\n  \"param_extensions.md\",\n  \"rbsteady.md\",\n  \"rbtransient.md\",\n  ]","category":"section"},{"location":"extensions/#GridapROMs.ParamFESpaces","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces","text":"","category":"section"},{"location":"extensions/#GridapROMs.Extensions.BlockExtension","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.BlockExtension","text":"struct BlockExtension <: ExtensionStyle\n  extension::Vector{<:ExtensionStyle}\nend\n\nExtension style for multi-field variables\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.DirectSumFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.DirectSumFESpace","text":"struct DirectSumFESpace{S<:SingleFieldFESpace,T<:SingleFieldFESpace} <: SingleFieldFESpace\n  space::EmbeddedFESpace{S,T}\n  complementary::EmbeddedFESpace\nend\n\nFE space which essentially acts as a wrapper around an EmbeddedFESpace space, but also stores its complementary space complementary obtained by calling complementary_space. This interface is useful for defining extension operators from space onto complementary\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.EmbeddedFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.EmbeddedFESpace","text":"struct EmbeddedFESpace{S<:SingleFieldFESpace,T<:SingleFieldFESpace} <: SingleFieldFESpace\n  space::S\n  bg_space::T\n  fdof_to_bg_fdofs::AbstractVector\n  ddof_to_bg_ddofs::AbstractVector\n  bg_cell_dof_ids::AbstractArray\nend\n\nRepresents a FE space space embedded in a background FE space bg_space. Fields:\n\nspace: target FE space\nbg_space: background FE space, which can be envisioned as the parent of space\nfdof_to_bg_fdofs: maps the active free DOFs in space to the active free\n\nDOFs in bg_space\n\nddof_to_bg_ddofs: maps the active dirichlet DOFs in space to the active dirichlet\n\nDOFs in bg_space\n\nbg_cell_dof_ids: connectivity of space on the background mesh, meaning that\n\nthe dof range and the number of cells are that of bg_space. NOTE: the DOFs here are NOT active, they are the internal ones\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.ExtensionAssembler","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.ExtensionAssembler","text":"struct ExtensionAssembler <: SparseMatrixAssembler\n  assem::SparseMatrixAssembler\n  trial_dof_to_bg_dofs::NTuple{2,AbstractVector}\n  test_dof_to_bg_dofs::NTuple{2,AbstractVector}\nend\n\nStructure that allows to decouple the assembly of FE matrices/vectors from the integration of weak formulations, to be used exclusively in the context of a trial/test couple of DirectSumFESpace. After performing integration on the FE space, the assembly is done on the background space. The latter step can be done by exploiting the fields\n\nassem: a SparseMatrixAssembler defined on the FE space\ntrial_dof_to_bg_dofs: index maps from the free/Dirichlet dofs on the trial FE space to those on the background trial space\ntest_dof_to_bg_dofs: index maps from the free/Dirichlet dofs on the test FE space to those on the background test space\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.ExtensionStyle","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.ExtensionStyle","text":"abstract type ExtensionStyle end\n\nAbstraction for different extension methods. Subtypes:\n\nZeroExtension\nMassExtension\nHarmonicExtension\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.HarmonicExtension","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.HarmonicExtension","text":"struct HarmonicExtension <: ExtensionStyle end\n\nExtension by means of a discrete Laplace operator\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.MassExtension","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.MassExtension","text":"struct MassExtension <: ExtensionStyle end\n\nExtension by means of a mass operator\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.MissingDofsFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.MissingDofsFESpace","text":"struct MissingDofsFESpace{V} <: SingleFieldFESpace\n  vector_type::Type{V}\n  nfree::Int\n  ndirichlet::Int\n  cell_dofs_ids::AbstractArray\n  fe_basis::CellField\n  fe_dof_basis::CellDof\n  cell_is_dirichlet::AbstractArray{Bool}\n  dirichlet_dof_tag::Vector{Int8}\n  dirichlet_cells::Vector{Int32}\n  ntags::Int\nend\n\nSame as an UnconstrainedFESpace in Gridap, with the possibilty using zeros to indicate constrained DOFs – i.e. DOFs that do not contribute to the assembly of FE vectors/matrices. Note: one could also use a FESpaceWithLinearConstraints instead, but that would be overly complicated in most scenarios\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.ZeroExtension","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.ZeroExtension","text":"struct ZeroExtension <: ExtensionStyle end\n\nExtension by zero\n\n\n\n\n\n","category":"type"},{"location":"extensions/#GridapROMs.Extensions.:⊕-Tuple{Gridap.FESpaces.FEFunction, Gridap.FESpaces.FEFunction}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.:⊕","text":"(⊕)(uh::FEFunction,vh::FEFunction) -> FEFunction\n\nGiven a FEFunction uh defined on a FE space and a FEFunction vh defined on its complementary (see complementary_space for more details), returns a FEFunction defined as their direct sum. In practice, the output's values coincides with those of uh on the DOFs associated with the space, and those of vh on the DOFs associated with the complementary\n\n\n\n\n\n","category":"method"},{"location":"extensions/#GridapROMs.Extensions.complementary_space-Tuple{EmbeddedFESpace}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.complementary_space","text":"complementary_space(space::EmbeddedFESpace) -> EmbeddedFESpace\n\nGiven a FE space space embedded in a background FE space, called for e.g. bg_space, computes the complementary of space embedded in bg_space, defined as the space with free and Dirichlet dofs belonging to bg_space whose intersection with free and Dirichlet dofs belonging to space is empty. The reference FE space coincides with that belonging to space\n\n\n\n\n\n","category":"method"},{"location":"extensions/#GridapROMs.Extensions.extend_solution!-Tuple{AbstractVector, ZeroExtension, Gridap.FESpaces.FESpace, AbstractVector}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.extend_solution!","text":"extend_solution!(u_bg::AbstractVector,ext::ExtensionStyle,f::FESpace,u::AbstractVector)\n\nIn-place version of extend_solution\n\n\n\n\n\n","category":"method"},{"location":"extensions/#GridapROMs.Extensions.extend_solution-Tuple{GridapROMs.Extensions.ExtensionStyle, Gridap.FESpaces.FESpace, AbstractVector}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.extend_solution","text":"extend_solution(ext::ExtensionStyle,f::FESpace,u::AbstractVector) -> AbstractVector\n\nExtension of the nodal values u associated with a FE function defined on f according to the extension style ext\n\n\n\n\n\n","category":"method"},{"location":"extensions/#GridapROMs.Extensions.harmonic_extension-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.FEFunction}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.harmonic_extension","text":"harmonic_extension(fout::SingleFieldFESpace,uh_in_bg::FEFunction) -> FEFunction\n\nGiven a FEFunction uh_in_bg defined on an EmbeddedFESpace – so that nodal and cell values are available on a background FE space, in addition to the FE space itself – it returns the harmonic extension to the complementary FE space fout\n\n\n\n\n\n","category":"method"},{"location":"extensions/#GridapROMs.Extensions.mass_extension-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.FEFunction}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.Extensions.mass_extension","text":"mass_extension(fout::SingleFieldFESpace,uh_in_bg::FEFunction) -> FEFunction\n\nGiven a FEFunction uh_in_bg defined on an EmbeddedFESpace – so that nodal and cell values are available on a background FE space, in addition to the FE space itself – it returns the mass extension to the complementary FE space fout\n\n\n\n\n\n","category":"method"}]
}
