var documenterSearchIndex = {"docs":
[{"location":"rbtransient/#GridapROMs.RBTransient","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient","text":"","category":"section"},{"location":"rbtransient/#GridapROMs.RBTransient.TransientIntegrationDomain","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.TransientIntegrationDomain","text":"struct TransientIntegrationDomain <: IntegrationDomain\n  domain_space::IntegrationDomain\n  indices_time::Vector{Int32}\nend\n\nIntegration domain for a projection operator in a transient problem\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.TransientMDEIMReduction","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.TransientMDEIMReduction","text":"struct TransientMDEIMReduction{A,R<:Reduction{A,EuclideanNorm}} <: AbstractMDEIMReduction{A}\n  reduction::R\n  combine::Function\nend\n\nMDEIM struct employed in transient problems. The field combine is a function used to group the reductions relative to the various Jacobians(in general, more than one in transient problems) in a smart way. We consider, for example, the ODE\n\ntfracdudt - nu Delta u = f   textin   Ω times 0T\n\nsubject to initial/boundary conditions. Upon applying a FE discretization in space, and a θ-method in time, one gets the space-time system\n\nA_theta u_theta = f_theta\n\nwhere\n\nA_theta = beginbmatrix\nA_1 + M  (theta Delta t)      \n- M  (theta Delta t)  A_2 + M  (theta Delta t)     \n - M  (theta Delta t)  A_3 + M  (theta Delta t)    \n  ddots  ddots   \n    - M  (theta Delta t)  A_n + M  (theta Delta t)\nendbmatrix\n\nu_theta = left(1-theta)u_0 + theta u_1 hdots (1-theta)u_n-1 + theta u_nright^T\n\nf_theta = leftf_1 hdots f_nright^T\n\nA_k = A(t_k-1 + theta Delta t)\n\nf_k = f(t_k-1 + theta Delta t)\n\nNote: instead of multiplying A_theta by u_theta, we multiply tildeA_theta by u, where\n\ntildeA_theta = tridiag((1-theta)A_k-1 - M  Delta t theta A_k + M  Delta t 0)\n\nWe now denote with Phi and Psi the spatial and temporal basis obtained by reducing the snapshots associated to the state variable u. The Galerkin projection of the space-time system is equal to hatA_thetahatu = hatf_theta, where hatu is the unknown, and\n\nbeginalign*\nhatA_theta = sumlimits_k=1^n-1 ( (1-θ) Phi^T A_k Phi - Phi^T M Phi  Delta t) otimes Psik-1^T Psik\n  + sumlimits_k=1^n (theta Phi^T A_k Phi + Phi^T M Phi  Delta t) otimes Psik^T Psik \n  = theta A_backwards + (1-theta)A_forwards + (M_backwards + M_forwards)  Delta t \nhatf_theta = sumlimits_k=1^n Phi^T f_k otimes Psik\nendalign*\n\nWe notice that the expression of hatA_theta can be written in a more general form as\n\nhatA_theta = combine_A(A_backwardsA_forwards) + combine_M(M_backwardsM_forwards)\n\nwhere combineA and combineM are two function specific to A and M:\n\nbeginalign*\ncombine_A(xy) = theta y + (1-theta)y \ncombine_M(xy) = (x - y)  Delta t\nendalign*\n\nThe same can be said of any time marching scheme. This is the meaning of the function combine. Note that for a time marching with p interpolation points (e.g. for theta method, p = 2) the combine functions will have to accept p arguments.\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.TransientProjection","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.TransientProjection","text":"struct TransientProjection <: Projection\n  projection_space::Projection\n  projection_time::Projection\nend\n\nProjection operator for transient problems, containing a spatial projection and a temporal one. The space-time projection operator is equal to\n\nprojection_time ⊗ projection_space\n\nwhich, for efficiency reasons, is never explicitly computed\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.TransientReduction","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.TransientReduction","text":"struct TransientReduction{A,B,RS<:Reduction{A,B},RT<:Reduction{A,EuclideanNorm}} <: Reduction{A,B}\n  reduction_space::RS\n  reduction_time::RT\nend\n\nWrapper for reduction methods in transient problems. The fields reduction_space and reduction_time respectively represent the spatial reduction method, and the temporal one\n\n\n\n\n\n","category":"type"},{"location":"rbtransient/#GridapROMs.RBTransient.time_enrichment-Tuple{SupremizerReduction, Projection, Any}","page":"GridapROMs.RBTransient","title":"GridapROMs.RBTransient.time_enrichment","text":"time_enrichment(red::SupremizerReduction,a_primal::Projection,basis_dual) -> AbstractMatrix\n\nTemporal supremizer enrichment. (Approximate) Procedure:\n\nfor every b_dual ∈ Col(basis_dual)\ncompute Φ_primal_dual = get_basis(a_primal)'*get_basis(b_dual)\ncompute v = kernel(Φ_primal_dual)\ncompute v′ = orth_complement(v,a_primal)\nenrich a_primal = [a_primal,v′]\n\n\n\n\n\n","category":"method"},{"location":"transient/#Usage-Transient-problem","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"","category":"section"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"In this example we solve a more complicated problem, namely a parameter- and time-dependent version of the Navier-Stokes equations.","category":"page"},{"location":"transient/#FE-code","page":"Usage - Transient problem","title":"FE code","text":"","category":"section"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"We start by loading the necessary packages  ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"using Gridap\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers\nusing GridapSolvers.NonlinearSolvers\nusing DrWatson\nusing Serialization\n\nusing GridapROMs\n\nimport Gridap.MultiField: BlockMultiFieldStyle","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"Next, we load a DiscreteModel from file (which can be found among the assets of the repo)","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"model_dir = datadir(joinpath(\"models\",\"model_circle_2d.json\"))\nΩₕ = DiscreteModelFromFile(model_dir)\nlabels = get_face_labeling(Ωₕ)\nadd_tag_from_tags!(labels,\"dirichlet0\",[\"walls_p\",\"walls\",\"cylinders_p\",\"cylinders\"])\nadd_tag_from_tags!(labels,\"dirichlet\",[\"inlet\"])","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"Now, we introduce the space of tuples (μ,t) ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"dt = 0.0025\nt0 = 0.0\ntf = 60*dt\n\npdomain = fill([1.0,10.0],3)\ntdomain = t0:dt:tf\nDt = TransientParamSpace(pdomain,tdomain)","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"The main difference with respect to the steady case is that we consider as realizations sets of tuples (μ,t). This allows for a much cleaner representation of the (μ,t)-dependence in the problem. ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"note: Note\n","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"Times are not sampled from a TransientParamSpace, in the sense that we consider the sets (μ,t) ∀ t ∈ t0:dt:tf, where μ is a sampled quantity.","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"The way in which we simultaneously evaluate parameter- and time-dependent functions is with the structure TransientParamFunction, which generalizes a ParamFunction to the transient case. For example, we can consider the following Dirichlet datum for our problem","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"const W = 0.5\ninflow(μ,t) = abs(1-cos(2π*t/tf)+μ[3]*sin(μ[2]*2π*t/tf)/100)\ng_in(μ,t) = x -> VectorValue(-x[2]*(W-x[2])*inflow(μ,t),0.0)\ngₚₜ_in(μ,t) = TransientParamFunction(g_in,μ,t)\ng_0(x,μ,t) = x -> VectorValue(0.0,0.0)\ngₚₜ_0(μ,t) = TransientParamFunction(g_0,μ,t)","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"which we use to define the FE spaces. We employ the Inf-Sup stable P2-P1 (Taylor-Hood) pair for velocity and pressure, respectively:","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"order = 2\nreffe_u = ReferenceFE(lagrangian,VectorValue{2,Float64},order)\ntest_u = TestFESpace(Ωₕ,reffe_u;conformity=:H1,dirichlet_tags=[\"dirichlet\",\"dirichlet0\"])\ntrial_u = TransientTrialParamFESpace(test_u,[gμt_in,gμt_0])\nreffe_p = ReferenceFE(lagrangian,Float64,order-1)\ntest_p = TestFESpace(Ωₕ,reffe_p;conformity=:H1)\ntrial_p = TransientTrialParamFESpace(test_p)\ntest = TransientMultiFieldParamFESpace([test_u,test_p];style=BlockMultiFieldStyle())\ntrial = TransientMultiFieldParamFESpace([trial_u,trial_p];style=BlockMultiFieldStyle())","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"A TransientTrialParamFESpace extends a traditional TransientTrialFESpace in Gridap, as it allows to provide a (μ,t)-dependent Dirichlet datum. The same holds for the multi-field version TransientMultiFieldParamFESpace. ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"note: Note\n","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"In the multi-field scenario, the BlockMultiFieldStyle style should always be used. Check the appropriate documentation of Gridap for more information.","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"Now we introduce the information related to the numerical integration ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"order = 2\ndegree = 2*order+1\nτₕ = Triangulation(Ωₕ)\ndΩₕ = Measure(τₕ,degree)","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"and then the problem's weak formulation ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"const Re = 100.0\na(x,μ,t) = μ[1]/Re\na(μ,t) = x->a(x,μ,t)\naμt(μ,t) = TransientParamFunction(a,μ,t)\n\nconv(u,∇u) = (∇u')⋅u\ndconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)\nc(u,v,dΩₕ) = ∫( v⊙(conv∘(u,∇(u))) )dΩₕ\ndc(u,du,v,dΩₕ) = ∫( v⊙(dconv∘(du,∇(du),u,∇(u))) )dΩₕ\n\nstiffness(μ,t,(u,p),(v,q),dΩₕ) = ∫(aμt(μ,t)*∇(v)⊙∇(u))dΩₕ - ∫(p*(∇⋅(v)))dΩₕ + ∫(q*(∇⋅(u)))dΩₕ\nmass(μ,t,(uₜ,pₜ),(v,q),dΩₕ) = ∫(v⋅uₜ)dΩₕ\nres(μ,t,(u,p),(v,q),dΩₕ) = ∫(v⋅∂t(u))dΩₕ + stiffness(μ,t,(u,p),(v,q),dΩₕ)\n\nres_nlin(μ,t,(u,p),(v,q),dΩₕ) = c(u,v,dΩₕ)\njac_nlin(μ,t,(u,p),(du,dp),(v,q),dΩₕ) = dc(u,du,v,dΩₕ)","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"Note that we have split the linear terms of the Navier-Stokes equations from the nonlinear convection terms, allowing us to increase efficiency of the algorithm. Now we introduce two FE operators, one for the linear terms and the other for the nonlinear ones:","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"trian_res = (τₕ,)\ntrian_jac = (τₕ,)\ntrian_jac_t = (τₕ,)\ndomains_lin = FEDomains(trian_res,(trian_jac,trian_jac_t))\ndomains_nlin = FEDomains(trian_res,(trian_jac,))\n\nfeop_lin = TransientParamLinearOperator((stiffness,mass),res,ptspace,\n  trial,test,domains_lin)\nfeop_nlin = TransientParamOperator(res_nlin,jac_nlin,ptspace,\n  trial,test,domains_nlin)\n\nfeop = LinearNonlinearTransientParamOperator(feop_lin,feop_nlin)","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"Next, we define the time marching scheme for our problem, along with a suitable initial condition ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"u0(x,μ) = VectorValue(0.0,0.0)\nu0(μ) = x->u0(x,μ)\nu0μ(μ) = ParamFunction(u0,μ)\np0(x,μ) = 0.0\np0(μ) = x->p0(x,μ)\np0μ(μ) = ParamFunction(p0,μ)\nxh0μ(μ) = interpolate_everywhere([u0μ(μ),p0μ(μ)],trial(μ,t0))\n\nnls = NewtonSolver(LUSolver();rtol=1e-10)\nθ = 1\nfesolver = ThetaMethod(nls,dt,θ)","category":"page"},{"location":"transient/#GridapROMs-code","page":"Usage - Transient problem","title":"GridapROMs code","text":"","category":"section"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"We finally discuss the code relative to the reduced part. As usual we start by defining the RBSolver of the problem ","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"coupling((du,dp),(v,q)) = ∫(dp*(∇⋅(v)))dΩₕ\nenergy((du,dp),(v,q)) = ∫(∇(v)⊙∇(du))dΩₕ + ∫(dp*q)dΩₕ\n\ntol = 1e-4\nstate_reduction = TransientReduction(coupling,tol,energy;nparams=50,sketch=:sprn)\nreduction_l = TransientMDEIMReduction(tol;nparams=40)\nreduction_a = TransientMDEIMReduction(tol;nparams=20)\nreduction_m = TransientMDEIMReduction(tol;nparams=1)\nreduction_am = (reduction_a,reduction_m)\nrbsolver = RBSolver(fesolver,state_reduction,reduction_l,reduction_am)\n","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"The main novelty is the use of transient reduction techniques. In particular:","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"A TransientReduction provides the information related to a reduction in space, and a reduction in time. \nA TransientMDEIMReduction provides the information related to a hyper-reduction in space, and a hyper-reduction in time. \nWhenever we provide a coupling variable in the reduction strategy, a reduction of type SupremizerReduction is returned. This type simply acts as a wrapper for a reduction strategy (of type TransientReduction in our case), and has the scope of performing a supremizer enrichment for the stabilization of the reduced problem. Check this reference for more details on supremizer stabilizations. They are useful, for e.g., when reducting saddle-point problems such as the Stokes or Navier-Stokes equations.","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"The subsequent steps procede as in a steady problem:","category":"page"},{"location":"transient/","page":"Usage - Transient problem","title":"Usage - Transient problem","text":"using DrWatson \nusing Serialization\n\ndir = datadir(\"navier-stokes\")\ncreate_dir(dir) \n\ntry # try loading offline quantities\n    rbop = load_operator(dir,feop)\ncatch # offline phase\n    rbop = reduced_operator(rbsolver,feop)\n    save(dir,rbop)\nend\n\nμon = realization(D;nparams=10,rand=true)\nx̂on,rbstats = solve(rbsolver,rbop,μon)\n\nxon,festats = solve(rbsolver,feop,μon)\nperf = eval_performance(rbsolver,feop,rbop,xon,x̂on,festats,rbstats)\nprintln(perf)","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributing to GridapROMs ==","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"By contributing to GridapROMs, you accept and agree to the following Developer Certificate of Origin Version 1.1 (see below) for all your contributions.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"contributing/#GridapROMs-Style-Guides","page":"Contributing","title":"GridapROMs Style Guides","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"2 spaces for indentation level\nNo trailing white spaces\nCamelCase for typenames\nPluralized CamelCase for files that implement a type\nCamelCasesTests for CamelCase type test file\nUse lowercase for methods, with underscores only when necessary\nUse whitespace for readability\n80 characterl line length limit\nUse method! for muting methods\nWrap multiline expressions in parentheses to avoid errors","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"See the Julia CONTRIBUTING.md for further information.","category":"page"},{"location":"tproduct/#GridapROMs.TProduct","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct","text":"","category":"section"},{"location":"tproduct/#GridapROMs.TProduct.MatrixOrTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.MatrixOrTensor","text":"const MatrixOrTensor = Union{AbstractMatrix,AbstractRankTensor}\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.AbstractRankTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.AbstractRankTensor","text":"abstract type AbstractRankTensor{D,K} end\n\nType representing a tensor a of dimension D and rank K, i.e. assuming the form\n\na = sumlimits_k=1^K a_1^k otimes cdots otimes a_D^k\n\nSubtypes:\n\nRank1Tensor\nGenericRankTensor\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.BlockRankTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.BlockRankTensor","text":"struct BlockRankTensor{A<:AbstractRankTensor,N} <: AbstractArray{A,N}\n  array::Array{A,N}\nend\n\nMulti-field version of a AbstractRankTensor\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.GenericRankTensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.GenericRankTensor","text":"struct GenericRankTensor{D,K,A<:AbstractArray} <: AbstractRankTensor{D,K}\n  decompositions::Vector{Rank1Tensor{D,A}}\nend\n\nStructure representing a generic rank-K tensor, i.e. assuming the form\n\na = sumlimits_k=1^K a_1^k otimes cdots otimes a_D^k\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.Rank1Tensor","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.Rank1Tensor","text":"struct Rank1Tensor{D,A<:AbstractArray} <: AbstractRankTensor{D,1}\n  factors::Vector{A}\nend\n\nStructure representing rank-1 tensors, i.e. assuming the form\n\na = a_1 otimes cdots otimes a_D\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductDiscreteModel","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductDiscreteModel","text":"TProductDiscreteModel{D,A,B} <: DiscreteModel{D,D} end\n\nTensor product discrete model, storing a vector of 1-D models models_1d of length D, and the D-dimensional model model defined as their tensor product.\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductFESpace","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductFESpace","text":"struct TProductFESpace{S} <: SingleFieldFESpace\n  space::S\n  spaces_1d::Vector{<:SingleFieldFESpace}\n  trian::TProductTriangulation\nend\n\nTensor product single field FESpace, storing a vector of 1-D FESpaces spaces_1d of length D, and the D-dimensional FESpace space defined as their tensor product. The tensor product triangulation trian is provided as a field to avoid incompatibility issues when passing to MultiField scenarios\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductMeasure","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductMeasure","text":"struct TProductMeasure{A,B} <: Measure\n  measure::A\n  measures_1d::B\nend\n\nTensor product measure, storing a vector of 1-D measures measures_1d of length D, and the D-dimensional measure measure defined as their tensor product.\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductSparseMatrixAssembler","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductSparseMatrixAssembler","text":"TProductSparseMatrixAssembler{A<:SparseMatrixAssembler} <: SparseMatrixAssembler\n\nAssembly-related information when constructing a AbstractRankTensor\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductTriangulation","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductTriangulation","text":"TProductTriangulation{Dt,Dp,A,B,C} <: Triangulation{Dt,Dp}\n\nTensor product triangulation, storing a tensor product model, a vector of 1-D triangulations trians_1d of length D, and the D-dimensional triangulation trian defined as their tensor product.\n\n\n\n\n\n","category":"type"},{"location":"tproduct/#GridapROMs.TProduct.TProductBlockSparseMatrixAssembler-Tuple{Gridap.MultiField.MultiFieldFESpace, Gridap.MultiField.MultiFieldFESpace}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.TProductBlockSparseMatrixAssembler","text":"TProductBlockSparseMatrixAssembler(trial::MultiFieldFESpace,test::MultiFieldFESpace\n  ) -> TProductSparseMatrixAssembler\n\nReturns a TProductSparseMatrixAssembler in a MultiField scenario\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_1d_tags-Union{Tuple{D}, Tuple{TProductDiscreteModel{D, A} where A<:(Gridap.Geometry.CartesianDiscreteModel{D}), Any}} where D","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_1d_tags","text":"get_1d_tags(model::TProductDiscreteModel,tags) -> Vector{Vector{Int8}}\n\nFetches the tags of the tensor product 1D models corresponding to the tags of the D-dimensional model tags. The length of the output is D\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_decomposition-Tuple{GridapROMs.TProduct.AbstractRankTensor, Integer}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_decomposition","text":"get_decomposition(a::AbstractRankTensor,k::Integer) -> Vector{<:AbstractArray}\n\nFor a tensor a of dimension D and rank K assuming the form\n\na = sumlimits_k=1^K a_1^k otimes cdots otimes a_D^k\n\nreturns the decomposition relative to the kth rank:\n\na_1^k hdots  a_D^k\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_tp_fe_basis-Tuple{TProductFESpace}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_tp_fe_basis","text":"get_tp_fe_basis(f::TProductFESpace) -> TProductFEBasis\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.get_tp_trial_fe_basis-Tuple{TProductFESpace}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.get_tp_trial_fe_basis","text":"get_tp_trial_fe_basis(f::TProductFESpace) -> TProductFEBasis\n\n\n\n\n\n","category":"method"},{"location":"tproduct/#GridapROMs.TProduct.tproduct_array-Tuple{Vector{<:AbstractArray}}","page":"GridapROMs.TProduct","title":"GridapROMs.TProduct.tproduct_array","text":"tproduct_array(arrays_1d::Vector{<:AbstractArray}) -> Rank1Tensor\ntproduct_array(op,arrays_1d::Vector{<:AbstractArray},gradients_1d::Vector{<:AbstractArray},args...) -> GenericRankTensor\n\nReturns a AbstractRankTensor storing the arrays arrays_1d (usually matrices) arising from an integration routine on D 1-d triangulations whose tensor product gives a D-dimensional triangulation. In the absence of the field gradients_1d, the output is a Rank1Tensor; when provided, the output is a GenericRankTensor\n\ntproduct_array(arrays_1d::Vector{<:BlockArray}) -> BlockRankTensor\ntproduct_array(op,arrays_1d::Vector{<:BlockArray},gradients_1d::Vector{<:BlockArray},args...) -> BlockRankTensor\n\nGeneralization of the previous functions to multi-field scenarios\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils","page":"GridapROMs.Utils","title":"GridapROMs.Utils","text":"","category":"section"},{"location":"utils/#GridapROMs.Utils.ArrayContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.ArrayContribution","text":"struct ArrayContribution{T,N,V,K} <: Contribution\n  values::V\n  trians::K\nend\n\nContribution whose field values are AbstractArrays\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.Contribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.Contribution","text":"abstract type Contribution end\n\nCollection of values corresponding to a set of triangulations. Similarly to DomainContribution, the values can be accessed by indexing the corresponding triangulation.\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.MatrixContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.MatrixContribution","text":"const MatrixContribution{T,V,K} = ArrayContribution{T,2,V,K}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.PartialDerivative","page":"GridapROMs.Utils","title":"GridapROMs.Utils.PartialDerivative","text":"struct PartialDerivative{N} <: Function end\n\nGridap Map that implements a partial derivative\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.TupOfArrayContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.TupOfArrayContribution","text":"const TupOfArrayContribution{T} = Tuple{Vararg{ArrayContribution{T}}}\n\nSpecifically allows to deal with tuples of Jacobians in unsteady settings\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.VectorContribution","page":"GridapROMs.Utils","title":"GridapROMs.Utils.VectorContribution","text":"const VectorContribution{T,V,K} = ArrayContribution{T,1,V,K}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.∂₁","page":"GridapROMs.Utils","title":"GridapROMs.Utils.∂₁","text":"const ∂₁ = PartialDerivative{1}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.∂₂","page":"GridapROMs.Utils","title":"GridapROMs.Utils.∂₂","text":"const ∂₂ = PartialDerivative{2}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.∂₃","page":"GridapROMs.Utils","title":"GridapROMs.Utils.∂₃","text":"const ∂₃ = PartialDerivative{3}\n\n\n\n\n\n","category":"type"},{"location":"utils/#GridapROMs.Utils.compute_error-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Vararg{Any}}} where {T, N}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.compute_error","text":"compute_error(\n  sol::AbstractArray{T,N},\n  sol_approx::AbstractArray{T,N},\n  args...\n  ) where {T,N} -> Number\n\nComputes the error between sol and sol_approx, by default in the Euclidean norm. A different norm (usually represented by a sparse matrix) can be provided as an argument.\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.compute_relative_error-Tuple{AbstractArray, AbstractArray, Vararg{Any}}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.compute_relative_error","text":"compute_relative_error(\n  sol::AbstractArray{T,N},\n  sol_approx::AbstractArray{T,N},\n  args...\n  ) where {T,N} -> Number\n\nComputes the relative error between sol and sol_approx, by default in the Euclidean norm. A different norm (usually represented by a sparse matrix) can be provided as an argument.\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.compute_speedup-Tuple{GridapROMs.Utils.CostTracker, GridapROMs.Utils.CostTracker}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.compute_speedup","text":"compute_speedup(t1::CostTracker,t2::CostTracker) -> Speedup\n\nComputes the speedup the tracker t2 achieves with respect to t1, in time and in memory footprint\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.contribution-Tuple{Any, Any}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.contribution","text":"contribution(f,trians) -> Contribution\n\nConstructor of a Contribution that allows do-block syntax. f is a function such that\n\nvalues[i] = f(trians[i]) for i...\n\nThis constructor first builds the tuple of values, then builds the Contribution object from values and trians\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.find_closest_view-Tuple{Any, Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.find_closest_view","text":"find_closest_view(\n  tparents::Tuple{Vararg{Triangulation}},\n  tchild::Triangulation\n  ) -> (Integer, Triangulation)\n\nFinds the approximate parent of tchild; it returns the parent's index and its view in the same indices as tchild (which should be a triangulation view)\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.get_parent-Tuple{Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.get_parent","text":"get_parent(t::Triangulation) -> Triangulation\n\nWhen t is a triangulation view, returns its parent; throws an error when t is not a triangulation view\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.is_included-Tuple{Gridap.Geometry.Triangulation, Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.is_included","text":"is_included(tchild::Triangulation,tparent::Triangulation) -> Bool\n\nReturns true if tchild is a triangulation included in tparent, false otherwise. This condition is not as strong as is_parent\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.is_parent-Tuple{Gridap.Geometry.Triangulation, Gridap.Geometry.Triangulation}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.is_parent","text":"is_parent(tparent::Triangulation,tchild::Triangulation) -> Bool\n\nReturns true if tchild is a triangulation view of tparent, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.merge_triangulations-Tuple{AbstractVector{<:Gridap.Geometry.Triangulation}}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.merge_triangulations","text":"merge_triangulations(trians::AbstractVector{<:Triangulation}) -> Triangulation\n\nGiven a tuple of triangulation views trians, returns the triangulation view on the union of the viewed cells. In other words, the minimum common integration domain is found\n\n\n\n\n\n","category":"method"},{"location":"utils/#GridapROMs.Utils.order_domains-Tuple{Any, Any}","page":"GridapROMs.Utils","title":"GridapROMs.Utils.order_domains","text":"order_domains(\n  tparents::Tuple{Vararg{Triangulation}},\n  tchildren::Tuple{Vararg{Triangulation}}\n  ) -> Tuple{Vararg{Triangulation}}\n\nOrders the triangulation children in the same way as the triangulation parents\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady","text":"","category":"section"},{"location":"param_steady/#GridapROMs.ParamSteady.FEDomains","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.FEDomains","text":"struct FEDomains{A,B}\n  domains_res::A\n  domains_jac::B\nend\n\nFields:\n\ndomains_res: triangulations relative to the residual (nothing by default)\ndomains_jac: triangulations relative to the Jacobian (nothing by default)\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.JointDomains","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.JointDomains","text":"struct JointDomains <: TriangulationStyle end\n\nTrait for a FE operator indicating that residuals/Jacobiansin this operator should be computed summing the contributions relative to each triangulation as occurs in Gridap\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.JointParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.JointParamFEOperator","text":"const JointParamFEOperator{O<:UnEvalOperatorType} = ParamFEOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.JointParamOpFromFEOp","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.JointParamOpFromFEOp","text":"const JointParamOpFromFEOp{O<:UnEvalOperatorType} = ParamOpFromFEOp{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.JointParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.JointParamOperator","text":"const JointParamOperator{O<:UnEvalOperatorType} = ParamOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearNonlinearParamEq","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearNonlinearParamEq","text":"struct LinearNonlinearParamEq <: UnEvalOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearNonlinearParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearNonlinearParamFEOperator","text":"struct LinearNonlinearParamFEOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: ParamFEOperator{O,T}\n  op_linear::ParamFEOperator\n  op_nonlinear::ParamFEOperator\nend\n\nInterface to accommodate the separation of terms depending on their linearity in a nonlinear problem. This allows to build and store once and for all linear residuals/Jacobians, and in the Newton-like iterations only evaluate and assemble only the nonlinear components\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearParamEq","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearParamEq","text":"struct LinearParamEq <: UnEvalOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.NonlinearParamEq","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.NonlinearParamEq","text":"struct NonlinearParamEq <: UnEvalOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamFEOpFromWeakForm","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamFEOpFromWeakForm","text":"struct ParamFEOpFromWeakForm{O<:UnEvalOperatorType,T<:TriangulationStyle} <: ParamFEOperator{O,T}\n  res::Function\n  jac::Function\n  pspace::ParamSpace\n  assem::Assembler\n  trial::FESpace\n  test::FESpace\n  domains::FEDomains\nend\n\nMost standard instance of a parametric FE operator\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamFEOperator","text":"abstract type ParamFEOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: FEOperator end\n\nParametric extension of a FEOperator in Gridap. Compared to a standard FEOperator, there are the following novelties:\n\na ParamSpace is provided, so that parametric realizations can be extracted directly from the ParamFEOperator\na function representing a norm matrix is provided, so that errors in the desired norm can be automatically computed\n\nSubtypes:\n\nParamFEOpFromWeakForm\nLinearNonlinearParamFEOperator\nTransientParamFEOperator\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamOpFromFEOp","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamOpFromFEOp","text":"struct ParamOpFromFEOp{O<:UnEvalOperatorType,T<:TriangulationStyle} <: ParamOperator{O,T}\n  op::ParamFEOperator{O,T}\nend\n\nWrapper that transforms a ParamFEOperator into an ParamOperator\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamOperator","text":"abstract type ParamOperator{O<:UnEvalOperatorType,T<:TriangulationStyle} <: NonlinearParamOperator end\n\nType representing algebraic operators when solving parametric differential problems\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.ParamTrialFESpace","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.ParamTrialFESpace","text":"const ParamTrialFESpace = UnEvalTrialFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.SplitDomains","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.SplitDomains","text":"struct SplitDomains <: TriangulationStyle end\n\nTrait for a FE operator indicating that residuals/Jacobiansin this operator should be computed keeping the contributions relative to each triangulation separate\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.SplitParamFEOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.SplitParamFEOperator","text":"const SplitParamFEOperator{O<:UnEvalOperatorType} = ParamFEOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.SplitParamOpFromFEOp","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.SplitParamOpFromFEOp","text":"const SplitParamOpFromFEOp{O<:UnEvalOperatorType} = ParamOpFromFEOp{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.SplitParamOperator","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.SplitParamOperator","text":"const SplitParamOperator{O<:UnEvalOperatorType} = ParamOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.TriangulationStyle","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.TriangulationStyle","text":"abstract type TriangulationStyle <: GridapType end\n\nSubtypes:\n\nJointDomains\nSplitDomains\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.UnEvalOperatorType","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.UnEvalOperatorType","text":"abstract type UnEvalOperatorType <: GridapType end\n\nType representing operators that are not evaluated yet. This may include operators representing transient problems (although the implementation in Gridap differs), parametric problems, and a combination thereof. Could become a supertype of ODEOperatorType in Gridap\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.UnEvalTrialFESpace","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.UnEvalTrialFESpace","text":"struct UnEvalTrialFESpace{A,B} <: SingleFieldFESpace\n  space::A\n  space0::B\n  dirichlet::Union{Function,AbstractVector{<:Function}}\nend\n\nStruct representing trial FE spaces that are not evaluated yet. This may include FE spaces representing transient problems (although the implementation in Gridap, called TransientTrialFESpace, does not fall into this category), parametric problems, and transient-parametric problems.\n\n\n\n\n\n","category":"type"},{"location":"param_steady/#GridapROMs.ParamSteady.LinearParamFEOperator-Tuple{Function, Function, Any, Any, Any}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.LinearParamFEOperator","text":"LinearParamFEOperator(res::Function,jac::Function,pspace,trial,test,args...\n  ) -> ParamFEOperator{LinearParamEq,TriangulationStyle}\n\nReturns a linear parametric FE operator\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.collect_cell_matrix_for_trian-Tuple{Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace, Gridap.CellData.DomainContribution, Gridap.Geometry.Triangulation}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.collect_cell_matrix_for_trian","text":"function collect_cell_matrix_for_trian(\n  trial::FESpace,\n  test::FESpace,\n  a::DomainContribution,\n  strian::Triangulation\n  ) -> Tuple{Vector{<:Any},Vector{<:Any},Vector{<:Any}}\n\nComputes the cell-wise data needed to assemble a global sparse matrix for a given input triangulation strian\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.collect_cell_vector_for_trian-Tuple{Gridap.FESpaces.FESpace, Gridap.CellData.DomainContribution, Gridap.Geometry.Triangulation}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.collect_cell_vector_for_trian","text":"function collect_cell_vector_for_trian(\n  test::FESpace,\n  a::DomainContribution,\n  strian::Triangulation\n  ) -> Tuple{Vector{<:Any},Vector{<:Any}}\n\nComputes the cell-wise data needed to assemble a global vector for a given input triangulation strian\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_dof_map_at_domains-Tuple{ParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_dof_map_at_domains","text":"get_dof_map_at_domains(op::ParamFEOperator) -> Contribution\n\nReturns the residual dof map restricted to every residual triangulation\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_fe_operator-Tuple{ParamOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_fe_operator","text":"get_fe_operator(op::ParamOperator) -> ParamFEOperator\n\nFetches the underlying FE operator of an algebraic operator op\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_param_space-Tuple{ParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_param_space","text":"get_param_space(feop::ParamFEOperator) -> ParamSpace\nget_param_space(feop::TransientParamFEOperator) -> TransientParamSpace\n\nReturns the space of parameters contained in feop\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.get_sparse_dof_map_at_domains-Tuple{ParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.get_sparse_dof_map_at_domains","text":"get_sparse_dof_map_at_domains(op::ParamFEOperator) -> Contribution\n\nReturns the Jacobian dof map restricted to every Jacobian triangulation\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.ParamSteady.join_operators-Tuple{LinearNonlinearParamFEOperator}","page":"GridapROMs.ParamSteady","title":"GridapROMs.ParamSteady.join_operators","text":"join_operators(op::LinearNonlinearParamFEOperator) -> ParamFEOperator\n\nJoins the linear/nonlinear parts of the operator and returns the resulting operator\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.Utils.change_domains-Tuple{GridapROMs.ParamSteady.JointParamFEOperator, Vararg{Any}}","page":"GridapROMs.ParamSteady","title":"GridapROMs.Utils.change_domains","text":"change_domains(op::ParamFEOperator,args...) -> ParamFEOperator\n\nChanges the triangulations for residual/jacobian; the resulting operator will have the same TriangulationStyle trait as the one of the input\n\n\n\n\n\n","category":"method"},{"location":"param_steady/#GridapROMs.Utils.set_domains-Tuple{GridapROMs.ParamSteady.JointParamFEOperator, Vararg{Any}}","page":"GridapROMs.ParamSteady","title":"GridapROMs.Utils.set_domains","text":"set_domains(op::ParamFEOperator,args...) -> JointParamFEOperator\n\nFixes the triangulations for residual/jacobian; the resulting operator will have the trait JointDomains activated\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures","text":"","category":"section"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SparseSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SparseSnapshots","text":"\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSparseSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSparseSnapshots","text":"\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamArray","text":"abstract type AbstractParamArray{T,N,A<:AbstractArray{T,N}} <: AbstractParamData{A,N} end\n\nType representing parametric abstract arrays of type A. Subtypes:\n\nParamArray\nParamSparseMatrix\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamArray3D","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamArray3D","text":"const AbstractParamArray3D{T} = AbstractParamArray{T,3,<:AbstractArray{T,3}}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamData","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamData","text":"abstract type AbstractParamData{T,N} <: AbstractArray{T,N} end\n\nType representing generic parametric quantities. Subtypes:\n\nParamNumber\nAbstractParamArray\nAbstractSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamFunction","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamFunction","text":"abstract type AbstractParamFunction{P<:Realization} <: Function end\n\nRepresentation of parametric functions with domain a parametric space. Subtypes:\n\nParamFunction\nTransientParamFunction\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamMatrix","text":"const AbstractParamMatrix{T} = AbstractParamArray{T,2,<:AbstractMatrix{T}}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractParamVector","text":"const AbstractParamVector{T} = AbstractParamArray{T,1,<:AbstractVector{T}}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractRealization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractRealization","text":"abstract type AbstractRealization end\n\nType representing parametric realizations, i.e. samples extracted from a given parameter space. Subtypes:\n\nRealization\nTransientRealization\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.AbstractSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.AbstractSnapshots","text":"abstract type AbstractSnapshots{T,N} <: AbstractParamData{T,N} end\n\nType representing N-dimensional arrays of snapshots. Subtypes must contain the following information:\n\ndata: a (parametric) array\nrealization: a subtype of AbstractRealization, representing the points in the parameter space used to compute the array data\ndof map: a subtype of AbstractDofMap, representing a reindexing strategy for the array data\n\nSubtypes:\n\nSnapshots\nBlockSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ArrayOfArrays","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ArrayOfArrays","text":"struct ArrayOfArrays{T,N,A<:AbstractArray{T,N}} <: ParamArray{T,N}\n  data::Vector{A}\nend\n\nParametric array with entries stored non-consecutively in memory. It is characterized by an inner size equal to size(data[1]), and parametric length equal to length(data), where data is a Vector{<:AbstractArray}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockConsecutiveParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockConsecutiveParamMatrix","text":"const BlockConsecutiveParamMatrix{T,A<:Matrix{<:ConsecutiveParamMatrix{T}},B} = BlockParamMatrix{T,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockConsecutiveParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockConsecutiveParamVector","text":"const BlockConsecutiveParamVector{T,A<:Vector{<:ConsecutiveParamVector{T}},B} = BlockParamVector{T,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockParamArray","text":"struct BlockParamArray{T,N,A<:AbstractArray{<:AbstractParamArray{T,N},N},B<:NTuple{N,AbstractUnitRange{Int}}} <: ParamArray{T,N}\n  data::A\n  axes::B\nend\n\nIs to a ParamArray as a BlockArray is to a regular AbstractArray\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockParamMatrix","text":"const BlockParamMatrix{T,A,B} = BlockParamArray{T,2,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockParamVector","text":"const BlockParamVector{T,A,B} = BlockParamArray{T,1,A,B}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.BlockSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.BlockSnapshots","text":"struct BlockSnapshots{S<:Snapshots,N} <: AbstractSnapshots{S,N}\n  array::Array{S,N}\n  touched::Array{Bool,N}\nend\n\nBlock container for Snapshots of type S in a MultiField setting. This type is conceived similarly to ArrayBlock in Gridap\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamArray","text":"struct ConsecutiveParamArray{T,N,M,A<:AbstractArray{T,M}} <: ParamArray{T,N}\n  data::A\nend\n\nParametric array with entries stored consecutively in memory. It is characterized by an inner size equal to size(data)[1:N], and parametric length equal to size(data,N+1), where data is an AbstractArray of dimension M = N+1\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamMatrix","text":"const ConsecutiveParamMatrix{T,A<:AbstractArray{T,3}} = ConsecutiveParamArray{T,2,3,A}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSC","text":"struct ConsecutiveParamSparseMatrixCSC{Tv,Ti<:Integer} <: ParamSparseMatrixCSC{Tv,Ti}\n  m::Int64\n  n::Int64\n  colptr::Vector{Ti}\n  rowval::Vector{Ti}\n  data::Matrix{Tv}\nend\n\nRepresents a vector of sparse matrices in CSC format, with entries stored consecutively in memory. For sake of coherence, an instance of ConsecutiveParamSparseMatrixCSC inherits from AbstractMatrix{<:SparseMatrixCSC{Tv,Ti} rather than AbstractVector{<:SparseMatrixCSC{Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSC{Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSR","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamSparseMatrixCSR","text":"struct ConsecutiveParamSparseMatrixCSR{Bi,Tv,Ti<:Integer} <: ParamSparseMatrixCSR{Bi,Tv,Ti}\n  m::Int64\n  n::Int64\n  rowptr::Vector{Ti}\n  colval::Vector{Ti}\n  data::Matrix{Tv}\nend\n\nRepresents a vector of sparse matrices in CSR format, with entries stored consecutively in memory. For sake of coherence, an instance of ConsecutiveParamSparseMatrixCSR inherits from AbstractMatrix{<:SparseMatrixCSR{Bi,Tv,Ti} rather than AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ConsecutiveParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ConsecutiveParamVector","text":"const ConsecutiveParamVector{T,A<:AbstractArray{T,2}} = ConsecutiveParamArray{T,1,2,A}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamBlock","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamBlock","text":"struct GenericParamBlock{A} <: ParamBlock{A}\n  data::Vector{A}\nend\n\nMost standard implementation of a ParamBlock\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamMatrix","text":"struct GenericParamMatrix{Tv,Ti} <: ParamArray{Tv,2}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\n  nrows::Vector{Ti}\nend\n\nParametric matrix with entries stored non-consecutively in memory\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSC","text":"struct GenericParamSparseMatrixCSC{Tv,Ti<:Integer} <: ParamSparseMatrixCSC{Tv,Ti}\n  m::Int64\n  n::Int64\n  colptr::Vector{Ti}\n  rowval::Vector{Ti}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\nend\n\nRepresents a vector of sparse matrices in CSC format, with entries stored non-consecutively in memory. For sake of coherence, an instance of GenericParamSparseMatrixCSC inherits from AbstractMatrix{<:SparseMatrixCSC{Tv,Ti} rather than AbstractVector{<:SparseMatrixCSC{Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSC{Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSR","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamSparseMatrixCSR","text":"struct GenericParamSparseMatrixCSR{Bi,Tv,Ti<:Integer} <: ParamSparseMatrixCSR{Bi,Tv,Ti}\n  m::Int64\n  n::Int64\n  rowptr::Vector{Ti}\n  colval::Vector{Ti}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\nend\n\nRepresents a vector of sparse matrices in CSR format, with entries stored non-consecutively in memory. For sake of coherence, an instance of GenericParamSparseMatrixCSR inherits from AbstractMatrix{<:SparseMatrixCSR{Bi,Tv,Ti} rather than AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}, but should conceptually be thought as an AbstractVector{<:SparseMatrixCSR{Bi,Tv,Ti}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericParamVector","text":"struct GenericParamVector{Tv,Ti} <: ParamArray{Tv,1}\n  data::Vector{Tv}\n  ptrs::Vector{Ti}\nend\n\nParametric vector with entries stored non-consecutively in memory\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericSnapshots","text":"struct GenericSnapshots{T,N,D,I,R,A} <: SteadySnapshots{T,N,D,I,R,A}\n  data::A\n  dof_map::I\n  realization::R\nend\n\nMost standard implementation of a SteadySnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.GenericTransientRealization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.GenericTransientRealization","text":"struct GenericTransientRealization{P,T,A} <: TransientRealization{P,T}\n  params::P\n  times::A\n  t0::T\nend\n\nMost standard implementation of a TransientRealization.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.HaltonSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.HaltonSampling","text":"struct HaltonSampling <: SamplingStyle end\n\nSampling according to a Halton sequence\n\nnote: Note\n\n\nHalton is a sequence, not a distribution, hence this sampling strategy repeats   realizations since the draws are not randomized; to draw different parameters,   one needs to provide a starting point in the sequence (start = 1 by default)\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.LatinHypercubeSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.LatinHypercubeSampling","text":"struct LatinHypercubeSampling <: SamplingStyle end\n\nSampling according to a Latin HyperCube distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ModeTransientSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ModeTransientSnapshots","text":"struct ModeTransientSnapshots{M<:ModeAxes,T,I,R,A<:UnfoldingTransientSnapshots{T,I,R}} <: TransientSnapshots{T,2,1,I,R,A}\n  snaps::A\n  mode::M\nend\n\nRepresents a TransientSnapshots with a TrivialDofMap indexing strategy as an AbstractMatrix with a system of mode-unfolding representations. Only two mode-unfolding representations are considered:\n\nMode1Axes:\n\n[u(x1,t1,μ1) ⋯ u(x1,t1,μP) u(x1,t2,μ1) ⋯ u(x1,t2,μP) u(x1,t3,μ1) ⋯ ⋯ u(x1,tT,μ1) ⋯ u(x1,tT,μP)]         ⋮             ⋮          ⋮            ⋮           ⋮              ⋮             ⋮   u(xN,t1,μ1) ⋯ u(xN,t1,μP) u(xN,t2,μ1) ⋯ u(xN,t2,μP) u(xN,t3,μ1) ⋯ ⋯ u(xN,tT,μ1) ⋯ u(xN,tT,μP)]\n\nMode2Axes:\n\n[u(x1,t1,μ1) ⋯ u(x1,t1,μP) u(x2,t1,μ1) ⋯ u(x2,t1,μP) u(x3,t1,μ1) ⋯ ⋯ u(xN,t1,μ1) ⋯ u(xN,t1,μP)]         ⋮             ⋮          ⋮            ⋮           ⋮              ⋮             ⋮   u(x1,tT,μ1) ⋯ u(x1,tT,μP) u(x2,tT,μ1) ⋯ u(x2,tT,μP) u(x3,tT,μ1) ⋯ ⋯ u(xN,tT,μ1) ⋯ u(xN,tT,μP)]\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.NormalSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.NormalSampling","text":"struct NormalSampling <: SamplingStyle end\n\nSampling according to a normal distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamArray","text":"abstract type ParamArray{T,N} <: AbstractParamArray{T,N,Array{T,N}} end\n\nType representing parametric arrays of type A. Subtypes:\n\nTrivialParamArray\nConsecutiveParamArray\nGenericParamVector\nGenericParamMatrix\nArrayOfArrays\nBlockParamArray\n\nAlso acts as a constructor according to the following rules:\n\nParamArray(A::AbstractArray{<:Number}) -> ParamNumber\nParamArray(A::AbstractArray{<:Number},plength::Int) -> TrivialParamArray\nParamArray(A::AbstractVector{<:AbstractArray}) -> ParamArray\nParamArray(A::AbstractVector{<:AbstractSparseMatrix}) -> ParamSparseMatrix\nParamArray(A::AbstractArray{<:ParamArray}) -> BlockParamArray\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamBlock","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamBlock","text":"abstract type ParamBlock{A} end\n\nType representing cell-wise quantities defined during the integration routine. They are primarily used when lazily evaluating parametric quantities on the mesh. The implementation of the lazy interface mimics that of ArrayBlock in Gridap. Subtypes: -GenericParamBlock -TrivialParamBlock\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamFunction","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamFunction","text":"struct ParamFunction{F,P} <: AbstractParamFunction{P}\n  fun::F\n  params::P\nend\n\nRepresentation of parametric functions with domain a parametric space. Given a function f : Ω₁ × ... × Ωₙ × D, where D is a ParamSpace, the evaluation of f in μ ∈ D returns the restriction of f to Ω₁ × ... × Ωₙ\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamMatrix","text":"const ParamMatrix{T} = ParamArray{T,2}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamNumber","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamNumber","text":"struct ParamNumber{T<:Number,A<:AbstractVector{T}} <: AbstractParamData{T,1}\n  data::A\nend\n\nUsed as a wrapper for non-array structures, e.g. factorizations or numbers\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSpace","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSpace","text":"struct ParamSpace{P<:AbstractVector{<:AbstractVector},S<:SamplingStyle} <: AbstractSet{Realization}\n  param_domain::P\n  sampling_style::S\nend\n\nFields:\n\nparam_domain: domain of definition of the parameters\nsampling_style: distribution on param_domain according to which we can sample the parameters (by default it is set to HaltonSampling)\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSparseMatrix","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSparseMatrix","text":"abstract type ParamSparseMatrix{Tv,Ti,A<:AbstractSparseMatrix{Tv,Ti}\n  } <: AbstractParamArray{Tv,2,A} end\n\nType representing parametric abstract sparse matrices of type A. Subtypes:\n\nParamSparseMatrixCSC\nParamSparseMatrixCSR\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSparseMatrixCSC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSparseMatrixCSC","text":"abstract type ParamSparseMatrixCSC{Tv,Ti} <: ParamSparseMatrix{Tv,Ti,SparseMatrixCSC{Tv,Ti}} end\n\nType representing parametric sparse matrices in CSC format. Subtypes:\n\nConsecutiveParamSparseMatrixCSC\nGenericParamSparseMatrixCSC\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamSparseMatrixCSR","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamSparseMatrixCSR","text":"abstract type ParamSparseMatrixCSR{Bi,Tv,Ti} <: ParamSparseMatrix{Tv,Ti,SparseMatrixCSR{Bi,Tv,Ti}} end\n\nType representing parametric sparse matrices in CSR format. Subtypes:\n\nConsecutiveParamSparseMatrixCSR\nGenericParamSparseMatrixCSR\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamVector","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamVector","text":"const ParamVector{T} = ParamArray{T,1}\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamVectorWithEntryInserted","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamVectorWithEntryInserted","text":"struct ParamVectorWithEntryInserted{T,A} <: ParamVector{T}\n  a::A\n  index::Int\n  value::Vector{T}\nend\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ParamVectorWithEntryRemoved","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ParamVectorWithEntryRemoved","text":"struct ParamVectorWithEntryRemoved{T,A} <: ParamVector{T}\n  a::A\n  index::Int\nend\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.Realization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.Realization","text":"struct Realization{P<:AbstractVector} <: AbstractRealization\n  params::P\nend\n\nRepresents standard parametric realizations, i.e. samples extracted from a given parameter space. The field params is most commonly a vector of vectors. When the parameters are scalars, they still need to be defined as vectors of vectors of unit length. In other words, we treat the case in which params is a vector of numbers as the case in which params is a vector of one vector.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.ReshapedSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.ReshapedSnapshots","text":"struct ReshapedSnapshots{T,N,N′,D,I,R,A<:SteadySnapshots{T,N′,D,I,R},B} <: SteadySnapshots{T,N,D,I,R,A}\n  snaps::A\n  size::NTuple{N,Int}\n  mi::B\nend\n\nRepresents a SteadySnapshots snaps whose size is resized to size. This struct is equivalent to ReshapedArray, and is only used to make sure the result of this operation is still a subtype of SteadySnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SamplingStyle","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SamplingStyle","text":"abstract type SamplingStyle end\n\nSubtypes:\n\nUniformSampling\nNormalSampling\nHaltonSampling\nLatinHypercubeSampling\nUniformTensorialSampling\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.Snapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.Snapshots","text":"abstract type Snapshots{T,N,D,I<:AbstractDofMap{D},R<:AbstractRealization,A}\n  <: AbstractSnapshots{T,N} end\n\nType representing a collection of parametric abstract arrays of eltype T, that are associated with a realization of type R. The (spatial) entries of any instance of Snapshots are indexed according to an index map of type I:AbstractDofMap{D}, where D encodes the spatial dimension. Note that, as opposed to subtypes of AbstractParamArray, which are arrays of arrays, subtypes of Snapshots are arrays of numbers.\n\nSubtypes:\n\nSteadySnapshots\nTransientSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SnapshotsAtIndices","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SnapshotsAtIndices","text":"struct SnapshotsAtIndices{T,N,D,I,R,A<:SteadySnapshots{T,N,D,I,R},B} <: SteadySnapshots{T,N,D,I,R,A}\n  snaps::A\n  prange::B\nend\n\nRepresents a SteadySnapshots snaps whose parametric range is restricted to the indices in prange. This type essentially acts as a view for suptypes of SteadySnapshots, at every space location, on a selected number of parameter indices. An instance of SnapshotsAtIndices is created by calling the function select_snapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.SteadySnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.SteadySnapshots","text":"abstract type SteadySnapshots{T,N,D,I,A} <: Snapshots{T,N,D,I,<:Realization,A} end\n\nSpatial specialization of an Snapshots. The dimension N of a SteadySnapshots is equal to D + 1, where D represents the number of spatial axes, to which a parametric dimension is added.\n\nSubtypes:\n\nGenericSnapshots\nSnapshotsAtIndices\nReshapedSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TensorialUniformSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TensorialUniformSampling","text":"struct TensorialUniformSampling <: SamplingStyle end\n\nSampling according to a tensorial uniform distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientGenericSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientGenericSnapshots","text":"struct TransientGenericSnapshots{T,N,D,I,R,A} <: TransientSnapshots{T,N,D,I,R,A}\n  data::A\n  dof_map::I\n  realization::R\nend\n\nMost standard implementation of a TransientSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientParamFunction","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientParamFunction","text":"struct TransientParamFunction{F,P,T} <: AbstractParamFunction{P}\n  fun::F\n  params::P\n  times::T\nend\n\nRepresentation of parametric functions with domain a transient parametric space. Given a function f : Ω₁ × ... × Ωₙ × D × [t₁,t₂], where [t₁,t₂] is a temporal domain and D is a ParamSpace, or equivalently f : Ω₁ × ... × Ωₙ × D × [t₁,t₂], where D is a TransientParamSpace, the evaluation of f in (μ,t) ∈ D × [t₁,t₂] returns the restriction of f to Ω₁ × ... × Ωₙ\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientParamSpace","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientParamSpace","text":"struct TransientParamSpace{P<:ParamSpace,T} <: AbstractSet{TransientRealization}\n  parametric_space::P\n  temporal_domain::T\nend\n\nFields:\n\nparametric_space: underlying parameter space\ntemporal_domain: underlying temporal space\n\nIt represents, in essence, the set of tuples (p,t) in parametric_space × temporal_domain\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientRealization","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientRealization","text":"abstract type TransientRealization{P<:Realization,T<:Real} <: AbstractRealization end\n\nRepresents temporal parametric realizations, i.e. samples extracted from a given parameter space for every time step in a temporal range. The most obvious application of this type are transient PDEs, where an initial condition is given. Following this convention, the initial time instant is kept separate from the other time steps.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientRealizationAt","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientRealizationAt","text":"struct TransientRealizationAt{P,T} <: TransientRealization{P,T}\n  params::P\n  t::Base.RefValue{T}\nend\n\nRepresents a GenericTransientRealization{P,T} at a certain time instant t. To avoid making it a mutable struct, the time instant t is stored as a Base.RefValue{T}.\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientReshapedSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientReshapedSnapshots","text":"struct TransientReshapedSnapshots{T,N,N′,D,I,R,A<:TransientSnapshots{T,N′,D,I,R},B} <: TransientSnapshots{T,N,D,I,R,A}\n  snaps::A\n  size::NTuple{N,Int}\n  mi::B\nend\n\nRepresents a TransientSnapshots snaps whose size is resized to size. This struct is equivalent to ReshapedArray, and is only used to make sure the result of this operation is still a subtype of TransientSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSnapshots","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSnapshots","text":"abstract type TransientSnapshots{T,N,D,I,R<:TransientRealization,A} <: Snapshots{T,N,D,I,R,A} end\n\nTransient specialization of a Snapshots. The dimension N of a SteadySnapshots is equal to D + 2, where D represents the number of spatial axes, to which a temporal and a parametric dimension are added.\n\nSubtypes:\n\nTransientGenericSnapshots\nGenericSnapshots\nTransientSnapshotsAtIndices\nTransientReshapedSnapshots\nTransientSnapshotsWithIC\nModeTransientSnapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSnapshotsAtIndices","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSnapshotsAtIndices","text":"struct TransientSnapshotsAtIndices{T,N,D,I,R,A<:TransientSnapshots{T,N,D,I,R},B,C} <: TransientSnapshots{T,N,D,I,R,A}\n  snaps::A\n  trange::B\n  prange::C\nend\n\nRepresents a TransientSnapshots snaps whose parametric and temporal ranges are restricted to the indices in prange and trange. This type essentially acts as a view for suptypes of TransientSnapshots, at every space location, on a selected number of parameter/time indices. An instance of TransientSnapshotsAtIndices is created by calling the function select_snapshots\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TransientSnapshotsWithIC","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TransientSnapshotsWithIC","text":"struct TransientSnapshotsWithIC{T,N,D,I,R,A,B<:TransientSnapshots{T,N,D,I,R,A}} <: TransientSnapshots{T,N,D,I,R,A}\n  initial_data::A\n  snaps::B\nend\n\nStores a TransientSnapshots snaps alongside a parametric initial condition initial_data\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TrivialParamArray","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TrivialParamArray","text":"struct TrivialParamArray{T<:Number,N,A<:AbstractArray{T,N}} <: ParamArray{T,N}\n  data::A\n  plength::Int\nend\n\nWrapper for a non-parametric array data that we wish assumed a parametric length\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.TrivialParamBlock","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.TrivialParamBlock","text":"struct TrivialParamBlock{A} <: ParamBlock{A}\n  data::A\n  plength::Int\nend\n\nWrapper for a non-paramentric quantity data that we wish assumed a parametric length plength\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.UniformSampling","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.UniformSampling","text":"struct UniformSampling <: SamplingStyle end\n\nSampling according to a uniform distribution\n\n\n\n\n\n","category":"type"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.change_mode-Tuple{GridapROMs.ParamDataStructures.UnfoldingTransientSnapshots}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.change_mode","text":"change_mode(s::ModeTransientSnapshots) -> ModeTransientSnapshots\n\nReturns the snapshots obtained by opposing the mode of s. The result is a subtype of AbstractMatrix with entries equal to those of s, but with swapped spatial and temporal axes\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.eltype2-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.eltype2","text":"eltype2(a) -> Type\n\nReturns the eltype of eltype(a), i.e. it extracts the eltype of a parametric entry of a\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.find_param_length-Tuple","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.find_param_length","text":"find_param_length(a...) -> Int\n\nReturns the parametric length of all parametric quantities. An error is thrown if there are no parametric quantities or if at least two quantities have different parametric length\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_all_data-Tuple{ParamArray}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_all_data","text":"get_all_data(A::ParamArray) -> AbstractArray{<:Any}\n\nReturns all the entries stored in A, assuming A stores its entries consecutively\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_at_time","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_at_time","text":"get_at_time(r::GenericTransientRealization,time) -> TransientRealizationAt\n\nReturns a TransientRealizationAt from a GenericTransientRealization at a time instant specified by time\n\n\n\n\n\n","category":"function"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_final_time-Tuple{GridapROMs.ParamDataStructures.GenericTransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_final_time","text":"get_final_time(r::GenericTransientRealization) -> Real\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_indexed_data-Tuple{Snapshots}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_indexed_data","text":"get_indexed_data(s::Snapshots) -> AbstractArray\n\nReturns the data in s reindexed according to the indexing strategy provided in s.\n\nnote: Note\n\n\nThis function is not lazy, and should be used with parsimony\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_initial_time-Tuple{GridapROMs.ParamDataStructures.GenericTransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_initial_time","text":"get_initial_time(r::GenericTransientRealization) -> Real\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_param_data-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_param_data","text":"get_param_data(a) -> Any\n\nReturns the parametric data of a, usually in the form of a AbstractVector or a NTuple\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_param_entry-Tuple{GridapROMs.ParamDataStructures.AbstractParamArray, Vararg{Any}}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_param_entry","text":"get_param_entry(A::AbstractParamArray{T},i...) where T -> Vector{eltype(T)}\n\nReturns a vector of the entries of A at index i, for every parameter. The length of the output is equals to param_length(A)\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_params-Tuple{GridapROMs.ParamDataStructures.AbstractRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_params","text":"get_params(r::AbstractRealization) -> Realization\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_realization-Tuple{GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_realization","text":"get_realization(s::AbstractSnapshots) -> AbstractRealization\n\nReturns the realizations associated to the snapshots s\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.get_times-Tuple{TransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.get_times","text":"get_times(r::TransientRealization) -> Any\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.global_parameterize-Tuple","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.global_parameterize","text":"global_parameterize(a,plength::Integer) -> AbstractParamArray\n\nReturns a AbstractParamArray with parametric length plength from a. This parameterization involves quantities defined at the global (or assembled) level. For local parameterizations, see the function local_parameterize\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.inneraxes-Tuple{GridapROMs.ParamDataStructures.AbstractParamArray}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.inneraxes","text":"inneraxes(A::AbstractParamArray) -> Tuple{Vararg{Base.OneTo}}\n\nReturns the axes of A for a single parameter\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.innerlength-Tuple{GridapROMs.ParamDataStructures.AbstractParamArray}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.innerlength","text":"innerlength(A::AbstractParamArray) -> Int\n\nReturns the length of A for a single parameter. Thus, the total entries of A is equals to param_length(A)*innerlength(A)\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.lazy_parameterize-Tuple{Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.lazy_parameterize","text":"lazy_parameterize(a,plength::Integer) -> Any\n\nLazy version of parameterize, does not allocate\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.local_parameterize-Tuple{Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.local_parameterize","text":"local_parameterize(a,plength::Integer) -> Any\n\nReturns a quantity with parametric length plength from a. This parameterization involves quantities defined at the local (or cell) level. For global parameterizations, see the function global_parameterize\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.num_params-Tuple{GridapROMs.ParamDataStructures.AbstractRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.num_params","text":"num_params(r::AbstractRealization) -> Int\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.num_times-Tuple{TransientRealization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.num_times","text":"get_times(r::TransientRealization) -> Int\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_eachindex-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_eachindex","text":"param_eachindex(a,i::Integer) -> Any\n\nReturns the parametric range of a 1:param_length(a)\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_getindex-Tuple{Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_getindex","text":"param_getindex(a,i::Integer) -> Any\n\nReturns the parametric entry of a at the index i ∈ {1,...,param_length(a)}\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_length-Tuple{Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_length","text":"param_length(a) -> Int\n\nReturns the parametric length of a\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.param_setindex!-Tuple{Any, Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.param_setindex!","text":"param_setindex!(a,v,i::Integer) -> Any\n\nSets the parametric entry of a to v at the index i ∈ {1,...,param_length(a)}\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.parameterize-Tuple{Any, Integer}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.parameterize","text":"parameterize(a,plength::Integer) -> Any\n\nReturns a quantity with parametric length plength from a. When a already possesses a parametric length, i.e. it is a parametrized quantity, it returns a\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.parameterize-Tuple{Function, Realization}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.parameterize","text":"parameterize(f::Function,r::Realization) -> ParamFunction\nparameterize(f::Function,r::TransientRealization) -> TransientParamFunction\n\nMethod that parameterizes an input quantity by a realization r\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.realization-Tuple{ParamSpace}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.realization","text":"realization(p::ParamSpace;nparams=1,sampling=get_sampling_style(p),kwargs...) -> Realization\nrealization(p::TransientParamSpace;nparams=1,sampling=get_sampling_style(p),kwargs...) -> TransientRealization\n\nExtraction of a set of nparams parameters from a given parametric space, by default according to the sampling strategy specified in p.\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.select_snapshots-Tuple{GridapROMs.ParamDataStructures.SteadySnapshots, Any}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.select_snapshots","text":"select_snapshots(s::SteadySnapshots,prange) -> SnapshotsAtIndices\nselect_snapshots(s::TransientSnapshots,trange,prange) -> TransientSnapshotsAtIndices\n\nRestricts the parametric range of s to the indices prange steady cases, to the indices trange and prange in transient cases, while leaving the spatial entries intact. The restriction operation is lazy.\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.shift!-Tuple{GridapROMs.ParamDataStructures.GenericTransientRealization, Real}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.shift!","text":"shift!(r::TransientRealization,δ::Real) -> Nothing\n\nIn-place uniform shifting by a constant δ of the temporal domain in the realization r\n\n\n\n\n\n","category":"method"},{"location":"param_data_structures/#GridapROMs.ParamDataStructures.space_dofs-Tuple{Snapshots}","page":"GridapROMs.ParamDataStructures","title":"GridapROMs.ParamDataStructures.space_dofs","text":"space_dofs(s::Snapshots{T,N,D}) where {T,N,D} -> NTuple{D,Integer}\n\nReturns the spatial size of the snapshots\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady","text":"","category":"section"},{"location":"rbsteady/#GridapROMs.RBSteady.AbstractMDEIMReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AbstractMDEIMReduction","text":"abstract type AbstractMDEIMReduction{A} <: Reduction{A,EuclideanNorm} end\n\nType representing a hyper-reduction approximation by means of a MDEIM algorithm. Check this for more details on MDEIM. This reduction strategy is usually employed only for the approximation of a residual and/or Jacobian of a differential problem. Note that orthogonality with respect to a norm other than the euclidean is not required for this reduction type.\n\nSubtypes:\n\nMDEIMReduction\nTransientMDEIMReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AbstractTTCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AbstractTTCore","text":"abstract type AbstractTTCore{T,N} <: AbstractArray{T,N} end\n\nType for nonstandard representations of tensor train cores.\n\nSubtypes:\n\nDofMapCore\nSparseCore\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AdaptiveReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AdaptiveReduction","text":"struct AdaptiveReduction{A,B,R<:DirectReduction{A,B}} <: GreedyReduction{A,B}\n  reduction::R\n  adaptive_nparams::Int\n  adaptive_tol::Float64\n  adaptive_maxiter::Int\nend\n\nNot implemented yet. Will serve as a parameter-adaptivity greedy reduction algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AffineContribution","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AffineContribution","text":"struct AffineContribution{A,V,K} <: Contribution\n\nContribution whose values assume one of the following types:\n\nHyperReduction for single field problems\nBlockProjection for multi field problems\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.AffineReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.AffineReduction","text":"struct AffineReduction{A,B} <: DirectReduction{A,B}\n  red_style::A\n  norm_style::B\nend\n\nReduction employed when the input data is independent with respect to the considered realization. Therefore, simply considering a number of parameters equal to 1 suffices for this type of reduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.BlockHyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.BlockHyperReduction","text":"const BlockHyperReduction{A<:HyperReduction,N} = BlockProjection{A,N}\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.BlockProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.BlockProjection","text":"struct BlockProjection{A,N} <: Projection end\n\nBlock container for Projection of type A in a MultiField setting. This type is conceived similarly to ArrayBlock in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.DirectReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.DirectReduction","text":"abstract type DirectReduction{A,B} <: Reduction{A,B} end\n\nType representing direct reduction methods, e.g. truncated POD, TTSVD, etc.\n\nSubtypes:\n\nAffineReduction\nPODReduction\nTTSVDReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.DofMapCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.DofMapCore","text":"struct DofMapCore{T,A<:AbstractArray{T,3},B<:AbstractArray} <: AbstractTTCore{T,3}\n  core::A\n  dof_map::B\nend\n\nRepresents a tensor train core core reindexed by means of an index mapping dof_map\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.EnergyNorm","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.EnergyNorm","text":"struct EnergyNorm <: NormStyle\n  norm_op::Function\nend\n\nTrait indicating that the reduction algorithm will produce a basis orthogonal in the norm specified by norm_op. Note: norm_op should represent a symmetric, positive definite bilinear form (matrix)\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.EuclideanNorm","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.EuclideanNorm","text":"struct EuclideanNorm <: NormStyle end\n\nTrait indicating that the reduction algorithm will produce a basis orthogonal in the euclidean norm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.EvalRBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.EvalRBSpace","text":"struct EvalRBSpace{A<:RBSpace,B<:AbstractRealization} <: RBSpace\n  subspace::A\n  realization::B\nend\n\nConceptually this isn't needed, but it helps dispatching according to steady/transient cases\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.FixedSVDRank","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.FixedSVDRank","text":"struct FixedSVDRank <: ReductionStyle\n  rank::Int\nend\n\nStruct employed when the chosen reduction algorithm is a truncated POD at a rank rank. Check this reference for more details on the truncated POD algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.GenericRBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.GenericRBOperator","text":"struct GenericRBOperator{O,A} <: RBOperator{O}\n  op::ParamOperator{O}\n  trial::RBSpace\n  test::RBSpace\n  lhs::A\n  rhs::AffineContribution\nend\n\nFields:\n\nop: underlying high dimensional FE operator\ntrial: reduced trial space\ntest: reduced trial space\nlhs: hyper-reduced left hand side\nrhs: hyper-reduced right hand side\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.HRParamArray","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.HRParamArray","text":"struct HRParamArray{T,N,A,B,C<:ParamArray{T,N}} <: ParamArray{T,N}\n  fecache::A\n  coeff::B\n  hypred::C\nend\n\nParametric vector returned after the online phase of a hyper-reduction strategy. Fields:\n\nfecache: represents a parametric residual/Jacobian computed via integration on an IntegrationDomain\ncoeff: parameter-dependent coefficient computed during the online phase according to the formula\ncoeff = Φi⁻¹ fecache[i,:]\nwhere (Φi,i) are the interpolation and the reduced integration domain stored in a HyperReduction object.\nhypred: the ouptut of the online phase of a hyper-reduction strategy, acoording to the formula\nhypred = Φrb * coeff\nwhere Φrb is the basis stored in a HyperReduction object\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.HyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.HyperReduction","text":"abstract type HyperReduction{\n  A<:Reduction,\n  B<:ReducedProjection,\n  C<:IntegrationDomain\n  } <: Projection end\n\nSubtype of a Projection dedicated to the outputd of a hyper-reduction (e.g. an empirical interpolation method (EIM)) procedure applied on residual/jacobians of a differential problem. This procedure can be summarized in the following steps:\n\ncompute a snapshots tensor T\nconstruct a Projection Φ by running the function reduction on T\nfind the EIM quantities (Φi,i), by running the function empirical_interpolation\n\non Φ\n\nThe triplet (Φ,Φi,i) represents the minimum information needed to run the online phase of the hyper-reduction. However, we recall that a RB method requires the (Petrov-)Galerkin projection of residuals/Jacobianson a reduced subspace built from solution snapshots, instead of providing the projection Φ we return the reduced projection Φrb, where\n\nfor residuals: Φrb = test_basisᵀ Φ\nfor Jacobians: Φrb = test_basisᵀ Φ trial_basis\n\nThe output of this operation is a ReducedProjection. Therefore, a HyperReduction is completely characterized by the triplet (Φrb,Φi,i). Subtypes:\n\nTrivialHyperReduction\nMDEIM\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.IntegrationDomain","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.IntegrationDomain","text":"abstract type IntegrationDomain end\n\nType representing the set of interpolation rows of a Projection subjected to a EIM approximation with empirical_interpolation. Subtypes:\n\nVectorDomain\nMatrixDomain\nTransientIntegrationDomain\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.InvProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.InvProjection","text":"struct InvProjection <: Projection\n  projection::Projection\nend\n\nRepresents the inverse map of a Projection projection\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.LRApproxRank","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.LRApproxRank","text":"struct LRApproxRank <: ReductionStyle\n  opts::LRAOptions\nend\n\nStruct employed when the chosen reduction algorithm is a randomized POD that leverages the package LowRankApprox. The field opts specifies the options needed to run the randomized POD\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.LinearNonlinearRBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.LinearNonlinearRBOperator","text":"struct LinearNonlinearRBOperator <: RBOperator{LinearNonlinearParamEq}\n  op_linear::RBOperator\n  op_nonlinear::RBOperator\nend\n\nExtends the concept of GenericRBOperator to accommodate the linear/nonlinear splitting of terms in nonlinear applications\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MDEIM","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MDEIM","text":"struct MDEIM{A,B,C} <: HyperReduction{A,B,C}\n  reduction::A\n  basis::B\n  interpolation::Factorization\n  domain::C\nend\n\nHyperReduction returned by a matrix-based empirical interpolation method\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MDEIMReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MDEIMReduction","text":"struct MDEIMReduction{A,R<:Reduction{A,EuclideanNorm}} <: AbstractMDEIMReduction{A}\n  reduction::R\nend\n\nMDEIM struct employed in steady problems\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MatrixDomain","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MatrixDomain","text":"struct MatrixDomain{T,S} <: IntegrationDomain\n  cells::Vector{Int32}\n  cell_irows::Table{T,Vector{T},Vector{Int32}}\n  cell_icols::Table{S,Vector{S},Vector{Int32}}\nend\n\nIntegration domain for a projection vector operator in a steady problem\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.MultiFieldRBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.MultiFieldRBSpace","text":"struct MultiFieldRBSpace <: RBSpace\n  space::MultiFieldFESpace\n  subspace::BlockProjection\nend\n\nReduced basis subspace of a MultiFieldFESpace in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.NormStyle","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.NormStyle","text":"abstract type NormStyle end\n\nSubtypes:\n\nEuclideanNorm\nEnergyNorm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.NormedProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.NormedProjection","text":"struct NormedProjection <: Projection\n  projection::Projection\n  norm_matrix::MatrixOrTensor\nend\n\nRepresents a Projection projection spanning a space equipped with an inner product represented by the quantity norm_matrix\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.PODProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.PODProjection","text":"struct PODProjection <: Projection\n  basis::AbstractMatrix\nend\n\nProjection stemming from a truncated proper orthogonal decomposition tpod\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.PODReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.PODReduction","text":"struct PODReduction{A,B} <: DirectReduction{A,B}\n  red_style::A\n  norm_style::B\n  nparams::Int\nend\n\nReduction by means of a truncated POD. The field nparams indicates the number of parameters selected for the computation of the snapshots\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.Projection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.Projection","text":"abstract type Projection <: Map end\n\nRepresents a basis for a n-dimensional vector subspace of a N-dimensional vector space (where N >> n), to be used as a Galerkin projection operator. The kernel of a Projection is n-dimensional, whereas its image is N-dimensional.\n\nSubtypes:\n\nPODProjection\nTTSVDProjection\nNormedProjection\nBlockProjection\nInvProjection\nReducedProjection\nHyperReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBOperator","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBOperator","text":"abstract type RBOperator{O} <: ParamOperator{O,SplitDomains} end\n\nType representing reduced algebraic operators used within a reduced order modelling framework in steady applications. A RBOperator should contain the following information:\n\na reduced test and trial space, computed according to reduced_spaces\na hyper-reduced residual and jacobian, computed according to reduced_weak_form\n\nSubtypes:\n\nGenericRBOperator\nLinearNonlinearRBOperator\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBParamVector","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBParamVector","text":"struct RBParamVector{T,A<:ParamVector{T},B} <: ParamArray{T,1}\n  data::A\n  fe_data::B\nend\n\nParametric vector obtained by applying a Projection on a high-dimensional parametric FE vector fe_data, which is stored (but mostly unused) for conveniency\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBSolver","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBSolver","text":"struct RBSolver{A<:GridapType,B} <: GridapType\n  fesolver::A\n  state_reduction::Reduction\n  residual_reduction::Reduction\n  jacobian_reduction::B\nend\n\nWrapper around a FE solver (e.g. NonlinearSolver or ODESolver in Gridap) with additional information on the reduced basis (RB) method employed to solve a given problem dependent on a set of parameters. A RB method is a projection-based reduced order model where\n\na suitable subspace of a FESpace is sought, of dimension n << Nₕ\na matrix-based discrete empirical interpolation method (MDEIM) is performed\n\nto approximate the manifold of the parametric residuals and jacobians\n\nthe EIM approximations are compressed with (Petrov-)Galerkin projections\n\nonto the subspace\n\nfor every desired choice of parameters, numerical integration is performed, and\n\nthe resulting n × n system of equations is cheaply solved\n\nIn particular:\n\ntol: tolerance used in the projection-based truncated proper orthogonal decomposition (TPOD) or in the tensor train singular value decomposition (TT-SVD), where a basis spanning the reduced subspace is computed; the value of tol is responsible for selecting the dimension of the subspace, i.e. n = n(tol)\nnparams_state: number of snapshots considered when running TPOD or TT-SVD\nnparams_res: number of snapshots considered when running MDEIM for the residual\nnparams_jac: number of snapshots considered when running MDEIM for the jacobian\nnparams_test:  number of snapshots considered when computing the error the RB method commits with respect to the FE procedure\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBSpace","text":"abstract type RBSpace <: FESpace end\n\nRepresents a vector subspace of a FESpace.\n\nSubtypes:\n\nSingleFieldRBSpace\nMultiFieldRBSpace\nEvalRBSpace\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.RBVector","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.RBVector","text":"struct RBVector{T,A<:AbstractVector{T},B} <: AbstractVector{T}\n  data::A\n  fe_data::B\nend\n\nVector obtained by applying a Projection on a high-dimensional FE vector fe_data, which is stored (but mostly unused) for conveniency\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ROMPerformance","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ROMPerformance","text":"struct ROMPerformance\n  error\n  speedup\nend\n\nAllows to compute errors and computational speedups to compare the properties of the algorithm with the FE performance.\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ReducedAlgebraicProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ReducedAlgebraicProjection","text":"\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ReducedProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ReducedProjection","text":"abstract type ReducedProjection{A<:AbstractArray} <: Projection end\n\nType representing a Galerkin projection of a Projection onto a reduced subspace represented by another Projection.\n\nSubtypes:\n\nReducedAlgebraicProjection\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.Reduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.Reduction","text":"abstract type Reduction{A<:ReductionStyle,B<:NormStyle} end\n\nType indicating the reduction strategy to employ, and the information regarding the norm with respect to which the reduction should occur.\n\nSubtypes:\n\nDirectReduction\nGreedyReduction\nSupremizerReduction\nAbstractMDEIMReduction\nTransientReduction\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.ReductionStyle","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ReductionStyle","text":"abstract type ReductionStyle end\n\nType indicating the reduction strategy to employ.\n\nSubtypes:\n\nSearchSVDRank\nFixedSVDRank\nLRApproxRank\nTTSVDRanks\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SearchSVDRank","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SearchSVDRank","text":"struct SearchSVDRank <: ReductionStyle\n  tol::Float64\nend\n\nStruct employed when the chosen reduction algorithm is a truncated POD at a tolerance tol. Check this reference for more details on the truncated POD algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SingleFieldRBSpace","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SingleFieldRBSpace","text":"struct SingleFieldRBSpace <: RBSpace\n  space::SingleFieldFESpace\n  subspace::Projection\nend\n\nReduced basis subspace of a SingleFieldFESpace in Gridap\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SparseCore","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SparseCore","text":"abstract type SparseCore{T,N} <: AbstractTTCore{T,N} end\n\nTensor train cores for sparse matrices.\n\nSubtypes:\n\nSparseCoreCSC\nSparseCoreCSC4D\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SparseCoreCSC","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SparseCoreCSC","text":"struct SparseCoreCSC{T,Ti} <: SparseCore{T,3}\n  array::Array{T,3}\n  sparsity::SparsityCSC{T,Ti}\nend\n\nTensor train cores for sparse matrices in CSC format\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SparseCoreCSC4D","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SparseCoreCSC4D","text":"struct SparseCoreCSC4D{T,Ti} <: SparseCore{T,4}\n  core::SparseCoreCSC{T,Ti}\n  sparse_indexes::Vector{CartesianIndex{2}}\nend\n\nTensor train cores for sparse matrices in CSC format, reshaped as 4D arrays\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.SupremizerReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.SupremizerReduction","text":"struct SupremizerReduction{A,R<:Reduction{A,EnergyNorm}} <: Reduction{A,EnergyNorm}\n  reduction::R\n  supr_op::Function\n  supr_tol::Float64\nend\n\nWrapper for reduction methods reduction that require an additional step of stabilization, by means of a supremizer enrichment. Check this for more details in a steady setting, and this for more details in a transient setting. The fields supr_op and supr_tol (which is only needed only in transient applications) are respectively the supremizing operator and the tolerance involved in the enrichment. For a saddle point problem with a Jacobian of the form\n\n[ A   Bᵀ   B   0 ]\n\nthis operator is given by the bilinear form representing the matrix Bᵀ.\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TTSVDProjection","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TTSVDProjection","text":"struct TTSVDProjection <: Projection\n  cores::AbstractVector{<:AbstractArray{T,3} where T}\n  dof_map::AbstractDofMap\nend\n\nProjection stemming from a tensor train SVD ttsvd. For reindexing purposes a field dof_map is provided along with the tensor train cores cores\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TTSVDRanks","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TTSVDRanks","text":"struct TTSVDRanks{T<:TTSVDStyle} <: ReductionStyle\n  style::Vector{<:ReductionStyle}\n  unsafe::T\nend\n\nStruct employed when the chosen reduction algorithm is a TTSVD, with reduction algorithm at each step specified in the vector of reduction styles style. Check this reference for more details on the TTSVD algorithm\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TTSVDReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TTSVDReduction","text":"struct TTSVDReduction{B} <: DirectReduction{TTSVDRanks,B}\n  red_style::TTSVDRanks\n  norm_style::B\n  nparams::Int\nend\n\nReduction by means of a TTSVD. The field nparams indicates the number of parameters selected for the computation of the snapshots\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.TrivialHyperReduction","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.TrivialHyperReduction","text":"struct TrivialHyperReduction{A,B} <: HyperReduction{A,B,IntegrationDomain}\n  reduction::A\n  basis::B\nend\n\nTrivial hyper-reduction returned whenever the residual/Jacobian is zero\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.VectorDomain","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.VectorDomain","text":"struct VectorDomain{T} <: IntegrationDomain\n  cells::Vector{Int32}\n  cell_irows::Table{T,Vector{T},Vector{Int32}}\nend\n\nIntegration domain for a projection vector operator in a steady problem\n\n\n\n\n\n","category":"type"},{"location":"rbsteady/#GridapROMs.RBSteady.allocate_hypred_cache-Tuple{GridapROMs.RBSteady.AffineContribution, GridapROMs.ParamDataStructures.AbstractRealization}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.allocate_hypred_cache","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.contraction-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{S, 3}}} where {T, S}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.contraction","text":"contraction(Φₗₖ::AbstractArray{T,3},Aₖ::AbstractArray{T,3}) -> AbstractArray{T,4}\ncontraction(Φₗₖ::AbstractArray{T,3},Aₖ::AbstractArray{T,3},Φᵣₖ::AbstractArray{T,3}) -> AbstractArray{T,6}\n\nContraction of tensor train cores, as a result of a (Petrov-)Galerkin projection. The contraction of Aₖ by Φₗₖ is the left-contraction of a TT core Aₖ by a (left, test) TT core Φₗₖ, whereas the contraction of Aₖ by Φᵣₖ is the right-contraction of a TT core Aₖ by a (right, trial) TT core Φᵣₖ. The dimension of the output of a contraction involving N factors is: 3N - N = 2N.\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.contraction-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector{S}}} where {T, S}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.contraction","text":"contraction(basis::AbstractArray,coefficient::AbstractArray) -> AbstractArray\n\nMultiplies a reduced basis basis by a set of reduced coeffiecients coefficient. It acts as a generalized linear combination, since basis might have a dimension higher than 2.\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.cores2basis-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.cores2basis","text":"cores2basis(cores::AbstractArray{T,3}...) -> AbstractMatrix\ncores2basis(dof_map::AbstractDofMap{D},cores::AbstractArray{T,3}...) -> AbstractMatrix\n\nReturns a basis in a matrix format from a list of tensor train cores cores. When also supplying the indexing strategy dof_map, the result is reindexed accordingly\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.create_dir-Tuple{String}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.create_dir","text":"create_dir(dir::String) -> Nothing\n\nRecursive creation of a directory dir; does not do anything if dir exists\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.empirical_interpolation-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.empirical_interpolation","text":"empirical_interpolation(a::Projection) -> (AbstractVector,AbstractMatrix)\n\nComputes the EIM of a. The outputs are:\n\na vector of integers i, corresponding to a list of interpolation row indices\na matrix Φi = view(Φ,i), where Φ = get_basis(a). This quantity represents the restricted basis on the set of interpolation rows i\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.enrich!-Tuple{SupremizerReduction, BlockProjection, BlockArrays.BlockMatrix{T} where T, BlockArrays.BlockMatrix{T} where T}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.enrich!","text":"enrich!(\n  red::SupremizerReduction,\n  a::BlockProjection,\n  norm_matrix::MatrixOrTensor,\n  supr_matrix::MatrixOrTensor) -> Nothing\n\nIn-place augmentation of the primal block of a BlockProjection a. This function has the purpose of stabilizing the reduced equations stemming from a saddle point problem\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.eval_performance-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots, GridapROMs.ParamDataStructures.AbstractSnapshots, GridapROMs.Utils.CostTracker, GridapROMs.Utils.CostTracker}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.eval_performance","text":"eval_performance(\n  solver::RBSolver,\n  feop::ParamOperator,\n  fesnaps::AbstractSnapshots,\n  rbsnaps::AbstractSnapshots,\n  festats::CostTracker,\n  rbstats::CostTracker\n  ) -> ROMPerformance\n\nArguments:\n\nsolver: solver for the reduced problem\nfeop: FE operator representing the PDE\nfesnaps: online snapshots of the FE solution\nrbsnaps: reduced approximation of fesnaps\nfestats: time and memory consumption needed to compute fesnaps\nrbstats: time and memory consumption needed to compute rbsnaps\n\nReturns the performance of the reduced algorithm, in terms of the (relative) error between rbsnaps and fesnaps, and the computational speedup between rbstats and festats\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.galerkin_projection-Tuple{AbstractMatrix, AbstractMatrix}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.galerkin_projection","text":"galerkin_projection(Φₗ,A) -> Any\ngalerkin_projection(Φₗ,A,Φᵣ) -> Any\n\nGalerkin projection of A on the subspaces specified by a (left, test) subspace Φₗ (row projection) and a (right, trial) subspace Φᵣ (column projection)\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.galerkin_projection-Tuple{Projection, Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.galerkin_projection","text":"galerkin_projection(a::Projection,b::Projection) -> ReducedProjection\ngalerkin_projection(a::Projection,b::Projection,c::Projection,args...) -> ReducedProjection\n\n(Petrov) Galerkin projection of a projection map b onto the subspace a (row projection) and, if applicable, onto the subspace c (column projection)\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_basis-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_basis","text":"get_basis(a::Projection) -> AbstractMatrix\n\nReturns the basis spanning the reduced subspace represented by the projection a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_dofs_to_cells-Tuple{AbstractArray{<:AbstractArray}, AbstractVector}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_dofs_to_cells","text":"get_dofs_to_cells(\n  cell_dof_ids::AbstractArray{<:AbstractArray},\n  dofs::AbstractVector\n  ) -> AbstractVector\n\nReturns the list of cells containing the dof ids dofs\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_fe_solver-Tuple{RBSolver}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_fe_solver","text":"get_fe_solver(s::RBSolver) -> NonlinearSolver\n\nReturns the underlying NonlinearSolver from a RBSolver s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_integration_domain-Tuple{GridapROMs.RBSteady.HyperReduction}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_integration_domain","text":"get_integration_domain(a::HyperReduction) -> IntegrationDomain\n\nFor a HyperReduction a represented by the triplet (Φrb,Φi,i), returns i\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_interpolation-Tuple{GridapROMs.RBSteady.HyperReduction}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_interpolation","text":"get_interpolation(a::HyperReduction) -> Factorization\n\nFor a HyperReduction a represented by the triplet (Φrb,Φi,i), returns Φi, usually stored as a Factorization\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.get_reduced_subspace-Tuple{RBSpace}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.get_reduced_subspace","text":"get_reduced_subspace(r::RBSpace) -> Projection\n\nReturns the Projection spanning the reduced subspace contained in r\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.gram_schmidt-Tuple{}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.gram_schmidt","text":"gram_schmidt(A::AbstractMatrix,args...) -> AbstractMatrix\ngram_schmidt(A::AbstractMatrix,X::AbstractSparseMatrix,args...) -> AbstractMatrix\n\nGram-Schmidt orthogonalization for a matrix A under a Euclidean norm. A (positive definite) sparse matrix X representing an inner product on the row space of A can be provided to make the result orthogonal under a different norm\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.inv_project!-Tuple{AbstractArray, Projection, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.inv_project!","text":"inv_project!(x::AbstractArray,a::Projection,x̂::AbstractArray) -> Nothing\n\nIn-place recasting of a low-dimensional object x̂ the high-dimensional space in which a is immersed\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.inv_project-Tuple{Projection, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.inv_project","text":"inv_project(a::Projection,x::AbstractArray) -> AbstractArray\n\nRecasts a low-dimensional object x onto the high-dimensional space in which a is immersed\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.jacobian_snapshots-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.jacobian_snapshots","text":"jacobian_snapshots(solver::RBSolver,op::ParamOperator,s::AbstractSnapshots;nparams) -> Contribution\njacobian_snapshots(solver::RBSolver,op::ODEParamOperator,s::AbstractSnapshots;nparams) -> Tuple{Vararg{Contribution}}\n\nReturns a Jacobian Contribution relative to the FE operator op. The quantity s denotes the solution snapshots in which we evaluate the jacobian. Note that we can select a smaller number of parameters nparams compared to the number of parameters used to compute s. In transient settings, the output is a tuple whose nth element is the Jacobian relative to the nth temporal derivative\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_contribution-Tuple{Any, Tuple{Vararg{Gridap.Geometry.Triangulation}}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_contribution","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_jacobians-Tuple{Any, ParamOperator}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_jacobians","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_operator-Tuple{Any, ParamOperator}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_operator","text":"load_operator(dir,feop::ParamOperator;kwargs...) -> RBOperator\n\nGiven a FE operator feop, load its reduced counterpart stored in the directory dir. Throws an error if the reduced operator has not been previously saved to file\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_reduced_subspace-Tuple{Any, Gridap.FESpaces.FESpace}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_reduced_subspace","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_residuals-Tuple{Any, ParamOperator}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_residuals","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_results-Tuple{Any}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_results","text":"\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.load_snapshots-Tuple{Any}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.load_snapshots","text":"load_snapshots(dir;label=\"\") -> AbstractSnapshots\n\nLoad the snapshots at the directory dir. Throws an error if the snapshots have not been previously saved to file\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.num_fe_dofs-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.num_fe_dofs","text":"num_fe_dofs(a::Projection) -> Int\n\nFor a projection map a from a low dimensional space n to a high dimensional one N, returns N\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.num_reduced_dofs-Tuple{Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.num_reduced_dofs","text":"num_reduced_dofs(a::Projection) -> Int\n\nFor a projection map a from a low dimensional space n to a high dimensional one N, returns n\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.orth_complement!-Tuple{AbstractVector, AbstractMatrix, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.orth_complement!","text":"orth_complement!(v::AbstractVector,basis::AbstractMatrix,args...) -> Nothing\n\nIn-place orthogonal complement of v on the column space of basis. When a symmetric, positive definite matrix X is provided as an argument, the output is X-orthogonal, otherwise it is ℓ²-orthogonal\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.orth_projection-Tuple{AbstractVector, AbstractMatrix}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.orth_projection","text":"orth_projection(v::AbstractVector, basis::AbstractMatrix, args...) -> AbstractVector\n\nOrthogonal projection of v on the column space of basis. When a symmetric, positive definite matrix X is provided as an argument, the output is X-orthogonal, otherwise it is ℓ²-orthogonal\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.plot_a_solution-Tuple{String, ParamOperator, Snapshots, Snapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.plot_a_solution","text":"plot_a_solution(\n  dir::String,\n  feop::ParamOperator,\n  sol::AbstractSnapshots,\n  sol_approx::AbstractSnapshots,\n  args...;\n  kwargs...\n  ) -> Nothing\n\nPlots a single FE solution, RB solution, and the point-wise error between the two, by selecting the first FE snapshot in sol and the first reduced snapshot in sol_approx\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.project!-Tuple{AbstractArray, Projection, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.project!","text":"project!(x̂::AbstractArray,a::Projection,x::AbstractArray,args...) -> Nothing\n\nIn-place projection of a high-dimensional object x onto the subspace represented by a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.project-Tuple{Projection, AbstractArray, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.project","text":"project(a::Projection,x::AbstractArray,args...) -> AbstractArray\n\nProjects a high-dimensional object x onto the subspace represented by a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.projection-Tuple{Reduction, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.projection","text":"projection(red::Reduction,s::AbstractArray) -> Projection\nprojection(red::Reduction,s::AbstractArray,X::MatrixOrTensor) -> Projection\n\nConstructs a Projection from a collection of snapshots s. An inner product represented by the quantity X can be provided, in which case the resulting Projection will be X-orthogonal\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_basis-Tuple{Reduction, GridapROMs.ParamDataStructures.AbstractSnapshots, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_basis","text":"reduced_basis(red::Reduction,s::AbstractSnapshots,args...) -> Projection\n\nComputes the basis by compressing the snapshots s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_jacobian-Tuple{RBSolver, ParamOperator, RBSpace, RBSpace, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_jacobian","text":"reduced_jacobian(\n  solver::RBSolver,\n  op::ParamOperator,\n  red_trial::RBSpace,\n  red_test::RBSpace,\n  s::AbstractSnapshots\n  ) -> Union{AffineContribution,TupOfAffineContribution}\n\nReduces the Jacobian contained in op via hyper-reduction. This function first builds the Jacobian snapshots, which are then reduced according to the strategy reduced_jacobian specified in the reduced solver solver. In transient applications, the output is a tuple of length equal to the number of Jacobians(i.e., equal to the order of the ODE plus one)\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_operator-Tuple{String, RBSolver, ParamOperator, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_operator","text":"reduced_operator(solver::RBSolver,feop::ParamOperator,args...;kwargs...) -> RBOperator\nreduced_operator(solver::RBSolver,feop::TransientParamOperator,args...;kwargs...) -> TransientRBOperator\n\nComputes a RB operator from the FE operator feop\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_residual-Tuple{RBSolver, ParamOperator, RBSpace, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_residual","text":"reduced_residual(\n  solver::RBSolver,\n  op::ParamOperator,\n  red_test::RBSpace,\n  s::AbstractSnapshots\n  ) -> AffineContribution\n\nReduces the residual contained in op via hyper-reduction. This function first builds the residual snapshots, which are then reduced according to the strategy residual_reduction specified in the reduced solver solver\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_spaces-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_spaces","text":"reduced_spaces(solver::RBSolver,feop::ParamOperator,s::AbstractSnapshots\n  ) -> (RBSpace, RBSpace)\n\nComputes the subspace of the test, trial FESpaces contained in the FE operator feop by compressing the snapshots s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_subspace-Tuple{Gridap.FESpaces.FESpace, Projection}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_subspace","text":"reduced_subspace(space::FESpace,basis::Projection) -> RBSpace\n\nGeneric constructor of a RBSpace from a FESpace space and a projection basis\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_triangulation-Tuple{Gridap.Geometry.Triangulation, GridapROMs.RBSteady.HyperReduction}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_triangulation","text":"reduced_triangulation(trian::Triangulation,a::HyperReduction)\n\nReturns the triangulation view of trian on the integration cells contained in a\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduced_weak_form-Tuple{RBSolver, ParamOperator, RBSpace, RBSpace, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduced_weak_form","text":"reduced_weak_form(\n  solver::RBSolver,\n  op::ParamOperator,\n  red_trial::RBSpace,\n  red_test::RBSpace,\n  s::AbstractSnapshots\n  ) -> (AffineContribution,Union{AffineContribution,TupOfAffineContribution})\n\nReduces the residual/Jacobian contained in op via hyper-reduction. Check the functions reduced_residual and reduced_jacobian for more details\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.reduction-Tuple{Reduction, AbstractArray}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.reduction","text":"reduction(red::Reduction,A::AbstractArray,args...) -> AbstractArray\nreduction(red::Reduction,A::AbstractArray,X::AbstractSparseMatrix) -> AbstractArray\n\nGiven an array (of snapshots) A, returns a reduced basis obtained by means of the reduction strategy red\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.residual_snapshots-Tuple{RBSolver, ParamOperator, GridapROMs.ParamDataStructures.AbstractSnapshots}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.residual_snapshots","text":"residual_snapshots(solver::RBSolver,op::ParamOperator,s::AbstractSnapshots;nparams) -> Contribution\nresidual_snapshots(solver::RBSolver,op::ODEParamOperator,s::AbstractSnapshots;nparams) -> Contribution\n\nReturns a residual Contribution relative to the FE operator op. The quantity s denotes the solution snapshots in which we evaluate the residual. Note that we can select a smaller number of parameters nparams compared to the number of parameters used to compute s\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.sequential_product-Tuple{Vararg{AbstractArray}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.sequential_product","text":"sequential_product(a::AbstractArray,b::AbstractArray...) -> AbstractArray\n\nThis function sequentially multiplies the results of several (sequential as well) calls to contraction\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.solution_snapshots-Tuple{RBSolver, ParamOperator, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.solution_snapshots","text":"solution_snapshots(solver::NonlinearSolver,feop::ParamOperator,r::Realization) -> SteadySnapshots\nsolution_snapshots(solver::ODESolver,feop::TransientParamOperator,r::TransientRealization,u0) -> TransientSnapshots\n\nThe problem encoded in the FE operator feop is solved several times, and the solution snapshots are returned along with the information related to the computational cost of the FE method. In transient settings, an initial condition u0 should be provided.\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.tpod-Tuple{GridapROMs.RBSteady.ReductionStyle, AbstractMatrix, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.tpod","text":"tpod(red_style::ReductionStyle,A::AbstractMatrix) -> AbstractMatrix\ntpod(red_style::ReductionStyle,A::AbstractMatrix,X::AbstractSparseMatrix) -> AbstractMatrix\n\nTruncated proper orthogonal decomposition of A. When provided, X is a (symmetric, positive definite) norm matrix with respect to which the output is made orthogonal. If X is not provided, the output is orthogonal with respect to the euclidean norm\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.ttsvd-Union{Tuple{N}, Tuple{T}, Tuple{GridapROMs.RBSteady.TTSVDRanks, AbstractArray{T, N}}} where {T, N}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.ttsvd","text":"ttsvd(red_style::TTSVDRanks,A::AbstractArray) -> AbstractVector{<:AbstractArray}\nttsvd(red_style::TTSVDRanks,A::AbstractArray,X::AbstractRankTensor) -> AbstractVector{<:AbstractArray}\n\nTensor train SVD of A. When provided, X is a norm tensor (representing a symmetric, positive definite matrix) with respect to which the output is made orthogonal. Note: if ndims(A) = N, the length of the ouptput is N-1, since we are not interested in reducing the axis of the parameters. Check this reference for more details\n\n\n\n\n\n","category":"method"},{"location":"rbsteady/#GridapROMs.RBSteady.union_bases-Tuple{Projection, Projection, Vararg{Any}}","page":"GridapROMs.RBSteady","title":"GridapROMs.RBSteady.union_bases","text":"union_bases(a::Projection,b::Projection,args...) -> Projection\n\nComputes the projection corresponding to the union of a and b. In essence this operation performs as\n\ngram_schmidt(union(get_basis(a),get_basis(b)))\n\n\n\n\n\n","category":"method"},{"location":"param_odes/#GridapROMs.ParamODEs","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs","text":"","category":"section"},{"location":"param_odes/#GridapROMs.ParamODEs.JointODEParamOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.JointODEParamOperator","text":"const JointODEParamOperator{O<:ODEParamOperatorType} = ODEParamOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.JointTransientParamFEOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.JointTransientParamFEOperator","text":"const JointTransientParamFEOperator{O<:ODEParamOperatorType} = TransientParamFEOperator{O,JointDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.LinearNonlinearParamODE","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.LinearNonlinearParamODE","text":"struct LinearNonlinearParamODE <: ODEParamOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.LinearParamODE","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.LinearParamODE","text":"struct LinearParamODE <: ODEParamOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.NonlinearParamODE","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.NonlinearParamODE","text":"struct NonlinearParamODE <: ODEParamOperatorType end\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ODEParamOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ODEParamOperator","text":"const ODEParamOperator{T<:ODEParamOperatorType,T<:TriangulationStyle} <: ParamOperator{O,T}\n\nTransient extension of the type ParamOperator.\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ODEParamOperatorType","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ODEParamOperatorType","text":"abstract type ODEParamOperatorType <: UnEvalOperatorType end\n\nParametric extension of the type ODEOperatorType in Gridap.\n\nSubtypes:\n\nNonlinearParamODE\nLinearParamODE\nLinearNonlinearParamODE\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ODEParamSolution","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ODEParamSolution","text":"struct ODEParamSolution{V} <: ODESolution\n  solver::ODESolver\n  odeop::ODEParamOperator\n  r::TransientRealization\n  us0::Tuple{Vararg{V}}\nend\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.ParamStageOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.ParamStageOperator","text":"struct ParamStageOperator{O} <: NonlinearParamOperator\n  op::ODEParamOperator{O}\n  r::TransientRealization\n  state_update::Function\n  ws::Tuple{Vararg{Real}}\n  paramcache::AbstractParamCache\nend\n\nStage operator to solve a parametric ODE with a time marching scheme\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.SplitODEParamOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.SplitODEParamOperator","text":"const SplitODEParamOperator{O<:ODEParamOperatorType} = ODEParamOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.SplitTransientParamFEOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.SplitTransientParamFEOperator","text":"const SplitTransientParamFEOperator{O<:ODEParamOperatorType} = TransientParamFEOperator{O,SplitDomains}\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientMultiFieldParamFESpace","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientMultiFieldParamFESpace","text":"const TransientMultiFieldParamFESpace = MultiFieldFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamFEOpFromWeakForm","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamFEOpFromWeakForm","text":"struct TransientParamFEOpFromWeakForm{T} <: TransientParamFEOperator{NonlinearParamODE,T}\n  res::Function\n  jacs::Tuple{Vararg{Function}}\n  tpspace::TransientParamSpace\n  assem::Assembler\n  trial::FESpace\n  test::FESpace\n  domains::FEDomains\n  order::Integer\nend\n\nInstance of TransientParamFEOperator, to be used when the transient problem is nonlinear\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamFEOperator","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamFEOperator","text":"const TransientParamFEOperator{O<:ODEParamOperatorType,T<:TriangulationStyle} = ParamFEOperator{O,T}\n\nParametric extension of a TransientFEOperator in Gridap. Compared to a standard TransientFEOperator, there are the following novelties:\n\na TransientParamSpace is provided, so that parametric realizations can be extracted directly from the TransientParamFEOperator\na function representing a norm matrix is provided, so that errors in the desired norm can be automatically computed\n\nSubtypes:\n\nTransientParamFEOpFromWeakForm\nTransientParamLinearFEOpFromWeakForm\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamFESolution","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamFESolution","text":"struct TransientParamFESolution{V} <: TransientFESolution\n  odesol::ODEParamSolution{V}\n  trial\nend\n\nWrapper around a TransientParamFEOperator and ODESolver that represents the parametric solution at a set of time steps. It is an iterator that computes the solution at each time step in a lazy fashion when accessing the solution.\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamLinearFEOpFromWeakForm","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamLinearFEOpFromWeakForm","text":"struct TransientParamLinearFEOpFromWeakForm{T} <: TransientParamFEOperator{LinearParamODE,T}\n  res::Function\n  jacs::Tuple{Vararg{Function}}\n  constant_forms::Tuple{Vararg{Bool}}\n  tpspace::TransientParamSpace\n  assem::Assembler\n  trial::FESpace\n  test::FESpace\n  domains::FEDomains\n  order::Integer\nend\n\nInstance of TransientParamFEOperator, to be used when the transient problem is linear\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientTrialParamFESpace","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientTrialParamFESpace","text":"const TransientTrialParamFESpace = UnEvalTrialFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_odes/#GridapROMs.ParamODEs.TransientParamLinearFEOperator-Tuple{Tuple{Vararg{Function}}, Function, Any, Any, Any}","page":"GridapROMs.ParamODEs","title":"GridapROMs.ParamODEs.TransientParamLinearFEOperator","text":"TransientParamLinearFEOperator(forms::Tuple{Vararg{Function}},res::Function,     tpspace,trial,test;kwargs...) -> TransientParamLinearFEOpFromWeakForm{TriangulationStyle}\n\nReturns a linear parametric FE operator\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps","text":"","category":"section"},{"location":"dof_maps/#GridapROMs.DofMaps.AbstractDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.AbstractDofMap","text":"abstract type AbstractDofMap{D,Ti} <: AbstractArray{Ti,D} end\n\nType representing an indexing strategy for FE quantitites (e.g. FE vectors such as FE solutions and residuals, or FE sparse matrices such as FE Jacobians). Subtypes:\n\nInverseDofMap\nVectorDofMap\nTrivialSparseMatrixDofMap\nSparseMatrixDofMap\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.CartesianSparsity","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.CartesianSparsity","text":"struct CartesianSparsity{A<:SparsityPattern,B<:AbstractVector,C<:AbstractVector} <: SparsityPattern\n  sparsity::A\n  bg_rows_to_act_rows::B\n  bg_cols_to_act_cols::C\nend\n\nFields:\n\nsparsity: the SparsityPattern of a matrix assembled on a (active) geometry which is either Cartesian, or it is defined from a (background) Cartesian geometry\nbg_rows_to_act_rows: a vector that maps a row of the Cartesian background geometry, to a row of the active geometry\nbg_cols_to_act_cols: a vector that maps a column of the Cartesian background geometry, to a column of the active geometry\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.DofMapArray","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.DofMapArray","text":"struct DofMapArray{T,D,Ti,A<:AbstractArray{T},I<:AbstractArray{Ti,D}} <: AbstractArray{T,D}\n  array::A\n  dof_map::I\nend\n\nSubtype of AbstractArray whose entries stored in array are indexed according to the indexing strategy specified in dof_map\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.DofToCell","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.DofToCell","text":"struct DofToCell{A} <: Map\n  cellids::A\nend\n\nInverse map of a standard connectivity structure: providing an input dof, returns a list of all the cells containing the dof\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.DofsToODofs","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.DofsToODofs","text":"struct DofsToODofs{D,P,V} <: Map\n  b::LagrangianDofBasis{P,V}\n  odof_to_dof::Vector{Int32}\n  node_and_comps_to_odof::Array{V,D}\n  orders::NTuple{D,Int}\nend\n\nMap used to convert a DOF of a standard FESpace in Gridap to a DOF belonging to a space whose DOFs are lexicographically-ordered\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.InverseDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.InverseDofMap","text":"struct InverseDofMap{D,Ti,I<:AbstractDofMap{D,Ti}} <: AbstractDofMap{D,Ti}\n  dof_map::I\nend\n\nInverse dof map of a given AbstractDofMap object dof_map\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OIdsToIds","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OIdsToIds","text":"struct OIdsToIds{T,A<:AbstractVector{<:Integer}} <: AbstractVector{T}\n  indices::Vector{T}\n  terms::A\nend\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OReindex","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OReindex","text":"struct OReindex{T<:Integer} <: Map\n  indices::Vector{T}\nend\n\nMap used to reindex according to the vector of integers indices\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OrderedFESpace","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OrderedFESpace","text":"abstract type OrderedFESpace{S} <: SingleFieldFESpace end\n\nInterface for FE spaces that feature a DOF reordering\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.Range1D","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.Range1D","text":"struct Range1D{I<:AbstractVector,J<:AbstractVector} <: AbstractVector{Int}\n  range::Range2D{I,J}\nend\n\nRepresents a Range2D reshaped as a vector\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.Range2D","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.Range2D","text":"struct Range2D{I<:AbstractVector,J<:AbstractVector} <: AbstractMatrix{Int}\n  axis1::I\n  axis2::J\n  scale::Int\nend\n\nCreates the indices of a Kronecker product matrix from the indices of the two factors. The field axis1 refers to the first factor, field axis2 refers to the second factor. The field scale is by default equal to the number of entries of the first factor.\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.SparseMatrixDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.SparseMatrixDofMap","text":"struct SparseMatrixDofMap{D,Ti,A<:SparsityPattern,B<:SparseDofMapStyle} <: AbstractDofMap{D,Ti}\n  d_sparse_dofs_to_sparse_dofs::Array{Ti,D}\n  d_sparse_dofs_to_full_dofs::Array{Ti,D}\n  sparsity::A\n  index_style::B\nend\n\nIndex map used to select the nonzero entries of a sparse matrix of sparsity sparsity. The nonzero entries are sorted according to the field d_sparse_dofs_to_sparse_dofs by default. For more details, check the function get_d_sparse_dofs_to_full_dofs\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.SparsityCSC","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.SparsityCSC","text":"struct SparsityCSC{Tv,Ti} <: SparsityPattern\n  matrix::SparseMatrixCSC{Tv,Ti}\nend\n\nSparsity pattern associated to a compressed sparse column matrix matrix\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.SparsityPattern","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.SparsityPattern","text":"abstract type SparsityPattern end\n\nType used to represent the sparsity pattern of a sparse matrix, usually the Jacobian in a FE problem.\n\nSubtypes:\n\nSparsityCSC\nCartesianSparsity\nTProductSparsity\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.TProductSparsity","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.TProductSparsity","text":"struct TProductSparsity{A<:SparsityPattern,B<:SparsityPattern} <: SparsityPattern\n  sparsity::A\n  sparsities_1d::Vector{B}\nend\n\nFields:\n\nsparsity: a SparsityPattern of a matrix assembled on a Cartesian geometry of dimension D\nsparsities_1d: a vector of D 1D sparsity patterns\n\nStructure used to represent a SparsityPattern of a matrix obtained by integrating a bilinear form on a triangulation that can be obtained as the tensor product of D 1D triangulations. For example, this can be done on a Cartesian mesh composed of D-cubes\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.TrivialDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.TrivialDofMap","text":"const TrivialDofMap{Ti} = AbstractDofMap{1,Ti}\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.TrivialSparseMatrixDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.TrivialSparseMatrixDofMap","text":"struct TrivialSparseMatrixDofMap{A<:SparsityPattern} <: TrivialDofMap{Int}\n  sparsity::A\nend\n\nIndex map used to select the nonzero entries of a sparse matrix of sparsity sparsity\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.VectorDofMap","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.VectorDofMap","text":"struct VectorDofMap{D,I<:AbstractVector{<:Integer}} <: AbstractDofMap{D,Int32}\n  size::Dims{D}\n  bg_dof_to_act_dof::I\nend\n\nDof map intended for the reindexing of FE vectors (e.g. FE solutions or residuals).\n\nFields:\n\nsize: denotes the desired shape of the reindexed array\nbg_dof_to_act_dof: vector mapping a background DOF to an active DOF. A background DOF lives on a FESpace defined on a background Cartesian mesh; an active DOF lives on a FESpace defined on an active mesh, which must occupy a portion of the background mesh. When the active mesh coincides with the background one, bg_dof_to_act_dof represents simply an identity map. If not, this means there are inactive DOFs in the background FESpace, which bg_dof_to_act_dof is responsible of masking.\n\nMore in detail, if size = (n1,...,nD), we can think of this mapping as a function\n\nn1 × ... × nD ⟶ {0,1,...,Nact}\n\nwhere Nact is the number of active DOFs. The output of this map is an index according to which we reindex FE vectors. We follow the convention that, when indexed by zero, the FE vectors return a zero. This is acceptable, since the FE vector does not actually hold a value when indexed at an inactive DOF.\n\n\n\n\n\n","category":"type"},{"location":"dof_maps/#GridapROMs.DofMaps.OrderedFEFunction-Tuple{OrderedFESpace, Any, Any}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.OrderedFEFunction","text":"OrderedFEFunction(f::OrderedFESpace,fv,dv) -> FEFunction\n\nReturns a FEFunction with correctly ordered values\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.add_ordered_entries!-Tuple{Function, Any, Nothing, GridapROMs.DofMaps.OIdsToIds, GridapROMs.DofMaps.OIdsToIds}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.add_ordered_entries!","text":"add_ordered_entries!(combine::Function,A,vs,is::OIdsToIds,js::OIdsToIds)\n\nAdds several ordered entries only for positive input indices. Returns A\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.change_dof_map-Tuple{GridapROMs.DofMaps.AbstractDofMap, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.change_dof_map","text":"change_dof_map(i::AbstractDofMap,args...) -> AbstractDofMap\n\nCreates a new dof map from an old dof map i\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.fast_index-Tuple{Any, Integer}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.fast_index","text":"fast_index(i,nfast::Integer) -> Any\n\nReturns the fast index in a tensor product structure. Suppose we have two matrices A and B of sizes Ra × Ca and Rb × Rb. Their kronecker product AB = A ⊗ B, of size RaRb × CaCb, can be indexed as\n\nAB[i,j] = A[slow_index(i,RbCb)] * B[fast_index(i,RbCb)],\n\nwhere nfast == RbCb. In other words, this function converts an index belonging to AB to an index belonging to B\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.flatten-Tuple{GridapROMs.DofMaps.AbstractDofMap}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.flatten","text":"flatten(i::AbstractDofMap) -> TrivialDofMap\n\nFlattens i, the output will be a dof map with ndims == 1\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.gather_ordered_free_and_dirichlet_values!-Tuple{Any, Any, OrderedFESpace, Any}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.gather_ordered_free_and_dirichlet_values!","text":"gather_ordered_free_and_dirichlet_values!(fv,dv,f::OrderedFESpace,cv) -> Nothing\n\nGathers correctly ordered free and dirichlet values\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_bg_dof_to_act_dof-Tuple{Gridap.FESpaces.FESpaceWithLinearConstraints}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_bg_dof_to_act_dof","text":"get_bg_dof_to_act_dof(f::FESpace,args...) -> AbstractVector{<:Integer}\n\nAssociates an active DOF to each background DOF of a FESpace f. This is done by computing the cumulative sum of the output of get_bg_dof_to_mask on f\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_bg_dof_to_mask-Tuple{Gridap.FESpaces.SingleFieldFESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_bg_dof_to_mask","text":"get_bg_dof_to_mask(f::FESpace,args...) -> Vector{Bool}\n\nAssociates a boolean mask to each background DOF of a FESpace f. If the DOF is active, the mask is false. If the DOF is inactive (e.g., because it is constrained), the mask is true\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_cell_odof_ids-Tuple{OrderedFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_cell_odof_ids","text":"get_cell_odof_ids(f::OrderedFESpace) -> AbstractArray\n\nFetches the ordered connectivity structure\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_d_sparse_dofs_to_full_dofs-Tuple{Any, Any, GridapROMs.DofMaps.TProductSparsity}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_d_sparse_dofs_to_full_dofs","text":"get_d_sparse_dofs_to_full_dofs(Tu,Tv,a::TProductSparsity) -> AbstractArray{<:Integer,D}\n\nInput:\n\nTu, Tv: DOF types of a trial FESpace U and test FESpace V, respecively\na: a TProductSparsity representing the sparsity of the matrix assembled from U and V\n\nOutput:\n\na D-array d_sparse_dofs_to_full_dofs, which represents a map from Nnz_1 × … × Nnz_{D} to M⋅N, where Nnz_i represents the number of nonzero entries of the ith 1D sparsity contained in a, and M⋅N is the total length of the tensor product sparse matrix in a. For vector-valued FESpaces, an additional axis is added to d_sparse_dofs_to_full_dofs representing the number of components. In particular, the component axis has a length equal to num_components(Tu)⋅num_components(Tv)\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_dof_eltype-Tuple{Gridap.FESpaces.FESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_dof_eltype","text":"get_dof_eltype(f::FESpace) -> Type\n\nFetches the DOF eltype for a FESpace f\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_dof_map-Tuple{Gridap.FESpaces.SingleFieldFESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_dof_map","text":"get_dof_map(space::FESpace) -> VectorDofMap\n\nReturns the active dofs sorted by coordinate order, for every dimension. If space is a D-dimensional, scalar FESpace, the output index map will be a subtype of AbstractDofMap{<:Integer,D}. If space is a D-dimensional, vector-valued FESpace, the output index map will be a subtype of AbstractDofMap{D+1}.\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_internal_dof_map-Tuple{Gridap.FESpaces.SingleFieldFESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_internal_dof_map","text":"get_internal_dof_map(space::FESpace) -> VectorDofMap\n\nReturns the internal dofs sorted by coordinate order, for every dimension. If space is a D-dimensional, scalar FESpace, the output index map will be a subtype of AbstractDofMap{<:Integer,D}. If space is a D-dimensional, vector-valued FESpace, the output index map will be a subtype of AbstractDofMap{D+1}.\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_polynomial_order-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_polynomial_order","text":"get_polynomial_order(f::FESpace) -> Integer\n\nRetrieves the polynomial order of f\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_polynomial_orders-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_polynomial_orders","text":"get_polynomial_orders(fs::FESpace) -> Integer\n\nRetrieves the polynomial order of fs for every dimension\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_sparse_dof_map-Tuple{Gridap.FESpaces.SingleFieldFESpace, Gridap.FESpaces.SingleFieldFESpace, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_sparse_dof_map","text":"get_sparse_dof_map(trial::FESpace,test::FESpace,args...) -> AbstractDofMap\n\nReturns the index maps related to Jacobiansin a FE problem. The default output is a TrivialSparseMatrixDofMap; when the trial and test spaces are of type TProductFESpace, a SparseMatrixDofMap is returned.\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.get_sparsity","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.get_sparsity","text":"get_sparsity(U::FESpace,V::FESpace,trian=_get_common_domain(U,V)) -> SparsityPattern\n\nBuilds a SparsityPattern from two FESpaces U and V, via integration on a triangulation trian\n\n\n\n\n\n","category":"function"},{"location":"dof_maps/#GridapROMs.DofMaps.invert-Tuple{GridapROMs.DofMaps.AbstractDofMap}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.invert","text":"invert(i::AbstractDofMap) -> InverseDofMap\n\nRetruns an InverseDofMap object out of an existing dof map i\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.range_1d-Tuple{AbstractVector, AbstractVector, Vararg{Any}}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.range_1d","text":"range_1d(i::AbstractVector,j::AbstractVector,args...) -> AbstractVector{Int}\n\nVectorization operation of a Range2D object\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.range_2d","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.range_2d","text":"range_2d(i::AbstractVector,j::AbstractVector,scale=length(i)) -> Range2D\n\nConstructor of a Range2D object\n\n\n\n\n\n","category":"function"},{"location":"dof_maps/#GridapROMs.DofMaps.recast-Tuple{AbstractArray, AbstractArray}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.recast","text":"recast(v::AbstractVector,a::AbstractSparseMatrix) -> AbstractSparseMatrix\n\nReturns a sparse matrix with values equal to v, and sparsity pattern equal to that of a\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.recast_indices-Tuple{AbstractArray, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.recast_indices","text":"recast_indices(fids::AbstractArray,a::AbstractSparseMatrix) -> AbstractArray\n\nInput:\n\na sparse matrix a of size (M,N) and a number of nonzero entries Nnz\nan array of indices sids with values ∈ {1,...,Nnz} (sparse indices)\n\nOutput:\n\nan array of indices fids with values ∈ {1,...,MN} (full indices), whose\n\nentries are associated to those of sids. Zero entries are preserved\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.recast_split_indices-Tuple{AbstractArray, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.recast_split_indices","text":"recast_split_indices(fids::AbstractArray,a::AbstractSparseMatrix) -> (AbstractArray,AbstractArray)\n\nInput:\n\na sparse matrix a of size (M,N) and a number of nonzero entries Nnz\nan array of indices sids with values ∈ {1,...,Nnz} (sparse indices)\n\nOutput:\n\nan array rows of indices frows with values ∈ {1,...,M} (full rows), whose\n\nentries are associated to those of sids. Zero entries are preserved\n\nan array rows of indices fcols with values ∈ {1,...,N} (full cols), whose\n\nentries are associated to those of sids. Zero entries are preserved\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.scatter_ordered_free_and_dirichlet_values-Tuple{OrderedFESpace, Any, Any}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.scatter_ordered_free_and_dirichlet_values","text":"scatter_ordered_free_and_dirichlet_values(f::OrderedFESpace,fv,dv) -> AbstractArray\n\nScatters correctly ordered free and dirichlet values\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.slow_index-Tuple{Any, Integer}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.slow_index","text":"slow_index(i,nfast::Integer) -> Any\n\nReturns the slow index in a tensor product structure. Suppose we have two matrices A and B of sizes Ra × Ca and Rb × Rb. Their kronecker product AB = A ⊗ B, of size RaRb × CaCb, can be indexed as\n\nAB[i,j] = A[slow_index(i,RbCb)]B[fast_index(i,RbCb)],\n\nwhere nfast == RbCb. In other words, this function converts an index belonging to AB to an index belonging to A\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.sparsify_indices-Tuple{AbstractArray, SparseArrays.AbstractSparseMatrix}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.sparsify_indices","text":"sparsify_indices(sids::AbstractArray,a::AbstractSparseMatrix) -> AbstractArray\n\nInput:\n\na sparse matrix a of size (M,N) and a number of nonzero entries Nnz\nan array of indices fids with values ∈ {1,...,MN} (full indices)\n\nOutput:\n\nan array of indices sids with values ∈ {1,...,Nnz} (sparse indices), whose\n\nentries are associated to those of fids. Zero entries are preserved\n\n\n\n\n\n","category":"method"},{"location":"dof_maps/#GridapROMs.DofMaps.vectorize-Tuple{GridapROMs.DofMaps.AbstractDofMap}","page":"GridapROMs.DofMaps","title":"GridapROMs.DofMaps.vectorize","text":"vectorize(i::AbstractDofMap) -> AbstractVector\n\nReshapes i as a vector, and removes the masked dofs in i (if any)\n\n\n\n\n\n","category":"method"},{"location":"#GridapROMs.jl","page":"Home","title":"GridapROMs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for GridapROMs. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe documentation is currently under construction.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools for the solution of parameterized partial differential equations (PDEs) with reduced order models (ROMs). The presence of parameters severely impacts the feasibility of running high-fidelity (HF) codes such as the finite element (FE) method, because typically the solution is required for many different values of the parameters. ROMs create surrogate models that approximate the solution manifold on a lower-dimensional manifold. (In linear ROMs, the manifold is a vector subspace, but more general nonlinear ROMs may be considered.) These surrogates provide accurate solutions in a much shorter time and with much fewer computational resources. Momentarily, the library supports the serial resolution of steady, transient, linear, nonlinear, single- and multi-field parameterized PDEs with the use of linear ROMs. ","category":"page"},{"location":"#Future-work","page":"Home","title":"Future work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We envision two main developments for the library. Firstly, the development of a scalable, distributed-in-memory interface. Secondly, the extension to nonlinear ROMs, for example models with an autoencoder-like structure, which have alredy been proven to be effective in the literature.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"utils.md\",\n  \"dof_maps.md\",\n  \"tproduct.md\",\n  \"param_data_structures.md\",\n  \"param_fe_spaces.md\",\n  \"param_steady.md\",\n  \"param_odes.md\",\n  \"rbsteady.md\",\n  \"rbtransient.md\",\n  ]","category":"page"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces","text":"","category":"section"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.MultiFieldParamFEFunction","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.MultiFieldParamFEFunction","text":"struct MultiFieldParamFEFunction{T<:MultiFieldCellField} <: ParamFEFunction\n  single_fe_functions::Vector{<:SingleFieldParamFEFunction}\n  free_values::AbstractArray\n  fe_space::MultiFieldFESpace\n  multi_cell_field::T\nend\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.MultiFieldParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.MultiFieldParamFESpace","text":"const MultiFieldParamFESpace = MultiFieldFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.ParamFEFunction","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.ParamFEFunction","text":"abstract type ParamFEFunction <: FEFunction end\n\nParametric extension of a FEFunction in Gridap. Subtypes:\n\nSingleFieldParamFEFunction\nMultiFieldParamFEFunction\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.SingleFieldParamFEFunction","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.SingleFieldParamFEFunction","text":"struct SingleFieldParamFEFunction{T<:CellField} <: ParamFEFunction\n  cell_field::T\n  cell_dof_values::AbstractArray{<:ParamBlock}\n  free_values::AbstractParamVector{<:Number}\n  dirichlet_values::AbstractParamVector{<:Number}\n  fe_space::SingleFieldFESpace\nend\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.SingleFieldParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.SingleFieldParamFESpace","text":"abstract type SingleFieldParamFESpace{S} <: SingleFieldFESpace end\n\nParametric extension of a SingleFieldFESpace in Gridap. The FE spaces inhereting are (trial) spaces on which we can easily define a ParamFEFunction.\n\nSubtypes:\n\nTrivialParamFESpace\nTrialParamFESpace\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.TrialParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.TrialParamFESpace","text":"TrialParamFESpace{S} <: SingleFieldParamFESpace{S}\n\nTrial FE space equipped with parametric dirichlet values\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.TrivialParamFESpace","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.TrivialParamFESpace","text":"TrivialParamFESpace{S} <: SingleFieldParamFESpace{S}\n\nWrapper for non-parametric FE spaces that we wish assumed a parametric length\n\n\n\n\n\n","category":"type"},{"location":"param_fe_spaces/#GridapROMs.ParamDataStructures.parameterize-Tuple{Gridap.FESpaces.SparseMatrixAssembler, GridapROMs.ParamDataStructures.AbstractRealization}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamDataStructures.parameterize","text":"parameterize(a::SparseMatrixAssembler,r::AbstractRealization) -> SparseMatrixAssembler\n\nReturns an assembler that also stores the parametric length of r. This function is to be used to assemble parametric residuals and Jacobians. The assembly routines follow the same pipeline as in Gridap\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.HomogeneousTrialParamFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, Int64}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.HomogeneousTrialParamFESpace","text":"HomogeneousTrialParamFESpace(U::SingleFieldFESpace,plength::Int) -> TrialParamFESpace\n\nReturns a TrialParamFESpace equipped with homogeneous parametric dirichlet values\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.TrialParamFESpace!-Tuple{GridapROMs.ParamDataStructures.AbstractParamVector{T} where T, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.TrialParamFESpace!","text":"TrialParamFESpace!(dir_values::AbstractParamVector,space::SingleFieldFESpace,objects\n  ) -> TrialParamFESpace\n\nAllows do-block syntax for the construction of a TrialParamFESpace\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.get_vector_type2-Tuple{Gridap.FESpaces.FESpace}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.get_vector_type2","text":"get_vector_type2(f::SingleFieldParamFESpace) -> Type\n\nReturns the vector type of the underlying un-parametric FESpace contained in f\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.param_zero_dirichlet_values-Tuple{Gridap.FESpaces.FESpace}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.param_zero_dirichlet_values","text":"param_zero_dirichlet_values(f::FESpace) -> AbstractParamVector\n\nParametric version of the function zero_dirichlet_values in Gridap\n\n\n\n\n\n","category":"method"},{"location":"param_fe_spaces/#GridapROMs.ParamFESpaces.param_zero_free_values-Tuple{Gridap.FESpaces.FESpace}","page":"GridapROMs.ParamFESpaces","title":"GridapROMs.ParamFESpaces.param_zero_free_values","text":"param_zero_free_values(f::FESpace) -> AbstractParamVector\n\nParametric version of the function zero_free_values in Gridap\n\n\n\n\n\n","category":"method"},{"location":"steady/#Usage-Steady-problem","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"","category":"section"},{"location":"steady/#Installation","page":"Usage - Steady problem","title":"Installation","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"GridapROMs is a registered package. You can install it by running:","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"# Use ] to enter the Pkg REPL mode\npkg> add GridapROMs","category":"page"},{"location":"steady/#Load-package","page":"Usage - Steady problem","title":"Load package","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Load the package normally with","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"using GridapROMs","category":"page"},{"location":"steady/#Workflow","page":"Usage - Steady problem","title":"Workflow","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The workflow of the package is analogous to that of Gridap, a library for the grid-based approximation of PDEs. Comprehensive Gridap tutorials can be found here. We load Gridap with ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"using Gridap","category":"page"},{"location":"steady/#Manufactured-solution","page":"Usage - Steady problem","title":"Manufactured solution","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"In this example we solve a parameter dependent Poisson equation ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"-ν*Δu  = f in Ω\nν*∇u⋅n = h in Γn","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"where Ω is a sufficiently regular spatial domain, ν is a (positive) conductivity coefficient, u is the problem's unknown, f is a forcing term, and h a Neumann datum defined on the Neumann boundary Γn. In this problem, we consider Ω = [0,1]^2 and Γn to be the right leg of the square. The remaining boundary is Dirichlet, and here we impose a manufactured, parameter-dependent solution. We consider the problem given by the following data: ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"ν(μ) = exp(-sum(μ))\nu(μ) = x -> μ[1]*x[1] + μ[2]*x[2]\nf(μ) = x -> -ν(μ)*Δ(u(x,μ))\nh(μ) = x -> 1","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Next, we parameterize the data defined above exclusively by μ in the following manner:","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"uₚ(μ) = ParamFunction(u,μ)\nfₚ(μ) = ParamFunction(f,μ)\nhₚ(μ) = ParamFunction(h,μ)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"A ParamFunction is a function that can be evaluated efficiently for any number of desired parameters. In a steady setting, it takes as argument a function (u, f and h in the cases above) and a parameter variable. In a transient setting, an additional time variable must be included (more details can be found in the following tutorial for transient problems).","category":"page"},{"location":"steady/#Geometry","page":"Usage - Steady problem","title":"Geometry","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"We define the geometry of the problem using ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Ω = (0,1,0,1)\npartition = (10,10)\nΩₕ = CartesianDiscreteModel(Ω,partition)","category":"page"},{"location":"steady/#FE-spaces","page":"Usage - Steady problem","title":"FE spaces","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Once the discrete geometry is introduced, we define a tuple of trial, test spaces (U,V) as","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"order = 1\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(Ωₕ,reffe;dirichlet_tags=[1,3,5,6,7])\nU = TrialParamFESpace(V,uₚ)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"A TrialParamFESpace extends a traditional TrialFESpace in Gridap, as it allows to provide a μ-dependent Dirichlet datum. The tags provided occupy the left, upper and bottom legs of the square (extrema excluded for the upper and bottom legs).","category":"page"},{"location":"steady/#Space-of-parameters","page":"Usage - Steady problem","title":"Space of parameters","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"We define a space of parameters, in this case [1,10]^2:","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"D = ParamSpace((1,10,1,10))","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"A parameter, in our case a 2-dimensional vector, is a single realization from D. By default, a parameter is sampled according to a Halton sequence. Other sampling methods can be defined by providing appropriate keyword arguments: ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"ParamSpace((1,10,1,10),sampling=:latin_hypercube)\nParamSpace((1,10,1,10),sampling=:normal)\nParamSpace((1,10,1,10),sampling=:uniform)\nParamSpace((1,10,1,10),sampling=:uniform_tensorial)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"A single parameter is sampled from D by calling","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"μ = realization(D) ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"whereas a collection of 10 realizations can be obtained by running","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"realization(D;nparams=10)","category":"page"},{"location":"steady/#Numerical-integration","page":"Usage - Steady problem","title":"Numerical integration","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Before introducing the weak formulation of the problem, we define the quantities needed for the numerical integration ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"degree = 2*order\nτₕ = Triangulation(Ωₕ)\nΓₕ = BoundaryTriangulation(Ω;tags=[2,4,8])\ndΩₕ = Measure(τₕ,degree)\ndΓₕ = Measure(Γₕ,degree)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The physical entities corresponding to the tags provided when defining Γₕ are: the bottom right vertex (2), the top right vertex (4) and the interior of the right edge (8).","category":"page"},{"location":"steady/#Weak-formulation","page":"Usage - Steady problem","title":"Weak formulation","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Multiplying the Poisson equation by a test function v ∈ V and integrating by parts yields the weak formulation of the problem, whose left- and right-hand (LHS & RHS) side are","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"a(μ,u,v,dΩₕ) = ∫(ν(μ)*∇(v)⋅∇(u))dΩₕ \nl(μ,v,dΩₕ,dΓₕ) = a(μ,u,v,dΩₕ) - ∫(fₚ(μ)*v)dΩₕ - ∫(hₚ(μ)*v)dΓₕ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Note that, in contrast to a traditional Gridap code, the measures involved in the forms are passed as arguments to the forms themselves. (This prevents us from defining a FE operator just by defining a bilinear form for the LHS and a linear form for the RHS as in Gridap: we must actually write the full expression of the residual). ","category":"page"},{"location":"steady/#Parametric-FE-problem","page":"Usage - Steady problem","title":"Parametric FE problem","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"At this point, we can build a FE operator representing the Poisson equation: ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"τₕ_l = (Ωₕ,Γₕ)\nτₕ_a = (Ωₕ,)\ndomains = FEDomains(τₕ_l,τₕ_a)\nfeop = ParamLinearFEOperator(l,a,D,U,V,domains)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The structure FEDomains collects the triangulations relative to the LHS & RHS. With respect to a traditional FE operator in Gridap, a ParamLinearFEOperator provides the aforementioned FEDomains for the LHS & RHS, as well as the parametric domain D.","category":"page"},{"location":"steady/#FE-solver","page":"Usage - Steady problem","title":"FE solver","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"We define the FE solver for our Poisson problem: ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"solver = LUSolver()","category":"page"},{"location":"steady/#RB-solver","page":"Usage - Steady problem","title":"RB solver","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Finally, we are ready to begin the GridapROMs part. The first part consists in defining the problem's RBSolver, i.e. the reduced counterpart of a FE solver:","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"tol = 1e-4\ninner_prod(u,v) = ∫(∇(v)⋅∇(u))dΩₕ\n\nreduction_sol = PODReduction(tol,inner_prod;nparams=20)\nreduction_l = MDEIMReduction(tol;nparams=10)\nreduction_a = MDEIMReduction(tol;nparams=10)\nrbsolver = RBSolver(solver,reduction_sol,reduction_l,reduction_a)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"A RBSolver contains the following information: ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The FE solver solver\nThe reduction strategy for the solution reduction_sol. This information is used to build a projection map representing a low-dimensional approximation subspace (i.e. a trial space) for our differential problem. In the case above, we use a truncated POD with tolerance tol on a set of 20 snapshots. The output is orthogonal with respect to the form inner_prod, i.e. the H^1_0 product. \nThe hyper-reduction strategy for the residual reduction_l. This information is used to build a projection map representing a low-dimensional subspace for the residual, equipped with a reduced integration domain obtained via MDEIM, i.e. the matrix-based empirical interpolation method. A total of 10 residual snapshots is used to compute the output.\nSimilarly, the hyper-reduction strategy for the Jacobian reduction_a.","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"note: Note\nOther reduction strategies include fixing the rank of the truncation    rank = 5\n    PODReduction(rank,inner_prod;nparams=20)and using randomized POD algorithms    PODReduction(tol,inner_prod;nparams=20,sketch=:sprn)A comprehensive documentation on randomized POD algorithms can be found here.","category":"page"},{"location":"steady/#Offline-phase","page":"Usage - Steady problem","title":"Offline phase","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The offline phase is the part of the code where the projection maps for the solution, LHS & RHS are computed. This phase is quite expensive to run, but on the upside it can just be run once, provided the outputs are saved to file. For this purpose, we load the well-known packages DrWatson and Serialization","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"using DrWatson \nusing Serialization","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"and define a saving directory for our example","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"dir = datadir(\"poisson\")\ncreate_dir(dir) ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"Next, we try loading the offline quantities; if the load fails, we must run the offline phase ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"try # try loading offline quantities\n    rbop = load_operator(dir,feop)\ncatch # offline phase\n    rbop = reduced_operator(rbsolver,feop)\n    save(dir,rbop)\nend","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The load might fail, for e.g., if ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"It is the first time running the code\nA different directory was used to save the offline structures in previous runs \nFor developers, if the definition of one of the loaded types has changed since it was saved to file ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The offline structures are completely contained in the variable rbop, which is the reduced version of the FE operator feop. To understand better the meaning of this variable, we report the content of the function reduced_operator:","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"# compute the solution snapshots \nfesnaps, = solution_snapshots(rbsolver,feop) \n# compute the reduced trial and test spaces \nÛ,V̂ = reduced_spaces(rbsolver,feop,fesnaps)\n# compute the hyper-reduction for LHS & RHS\nâ,l̂ = reduced_weak_form(rbsolver,feop,Û,V̂,fesnaps)\n\n# fetch the reduced FEDomains\nτₕ_l̂,τₕ_â = get_domains(l̂),get_domains(â)\n# replace the original FEDomains with the reduced ones  \nop′ = change_domains(op,τₕ_l̂,τₕ_â)\n# definition of reduced operator \nrbop = GenericRBOperator(op′,Û,V̂,â,l̂)","category":"page"},{"location":"steady/#Online-phase","page":"Usage - Steady problem","title":"Online phase","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"This step consists in computing the GridapROMs approximation for any desired parameter. We consider, for e.g., 10 parameters distributed uniformly on D","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"μon = realization(D;nparams=10,rand=true)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"and we solve the reduced problem ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"x̂on,rbstats = solve(rbsolver,rbop,μon)","category":"page"},{"location":"steady/#Post-processing","page":"Usage - Steady problem","title":"Post processing","text":"","category":"section"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"In order to test the quality of the approximation x̂on, we can run the following post-processing code ","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"xon,festats = solve(rbsolver,feop,μon)\nperf = eval_performance(rbsolver,feop,rbop,xon,x̂on,festats,rbstats)\nprintln(perf)","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"In other words, we first compute the HF solution xon in the online parameters μon, and then we run the performance tester, which in particular returns","category":"page"},{"location":"steady/","page":"Usage - Steady problem","title":"Usage - Steady problem","text":"The relative error ||xon - x̂on|| / ||xon||, averaged on the 10 parameters in μon. The norm is the one specified by inner_prod, so in our case the H^1_0 product.\nThe speedup in terms of time and memory achieved with respect to the HF simulations. This is done by comparing the variables rbstats and festats, which contain the time (in seconds) and memory allocations (in Gb) of the two algorithms.","category":"page"}]
}
