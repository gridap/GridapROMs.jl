<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage - steady problem · ROM.jl</title><meta name="title" content="Usage - steady problem · ROM.jl"/><meta property="og:title" content="Usage - steady problem · ROM.jl"/><meta property="twitter:title" content="Usage - steady problem · ROM.jl"/><meta name="description" content="Documentation for ROM.jl."/><meta property="og:description" content="Documentation for ROM.jl."/><meta property="twitter:description" content="Documentation for ROM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ROM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ROM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Usage</span><ul><li class="is-active"><a class="tocitem" href>Usage - steady problem</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Load-package"><span>Load package</span></a></li><li><a class="tocitem" href="#Workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#Manufactured-solution"><span>Manufactured solution</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#FE-spaces"><span>FE spaces</span></a></li><li><a class="tocitem" href="#Space-of-parameters"><span>Space of parameters</span></a></li><li><a class="tocitem" href="#Numerical-integration"><span>Numerical integration</span></a></li><li><a class="tocitem" href="#Weak-formulation"><span>Weak formulation</span></a></li><li><a class="tocitem" href="#Parametric-FE-problem"><span>Parametric FE problem</span></a></li><li><a class="tocitem" href="#FE-solver"><span>FE solver</span></a></li><li><a class="tocitem" href="#RB-solver"><span>RB solver</span></a></li><li><a class="tocitem" href="#Offline-phase"><span>Offline phase</span></a></li><li><a class="tocitem" href="#Online-phase"><span>Online phase</span></a></li><li><a class="tocitem" href="#Post-processing"><span>Post processing</span></a></li></ul></li><li><a class="tocitem" href="../transient/">Usage - transient problem</a></li></ul></li><li><span class="tocitem">FEM Interface</span><ul><li><a class="tocitem" href="../utils/">ROM.Utils</a></li><li><a class="tocitem" href="../dof_maps/">ROM.DofMaps</a></li><li><a class="tocitem" href="../tproduct/">ROM.TProduct</a></li><li><a class="tocitem" href="../param_data_structures/">ROM.ParamDataStructures</a></li><li><a class="tocitem" href="../param_algebra/">ROM.ParamAlgebra</a></li><li><a class="tocitem" href="../param_fe_spaces/">ROM.ParamFESpaces</a></li><li><a class="tocitem" href="../param_steady/">ROM.ParamSteady</a></li><li><a class="tocitem" href="../param_odes/">ROM.ParamODEs</a></li></ul></li><li><span class="tocitem">ROM Interface</span><ul><li><a class="tocitem" href="../rbsteady/">ROM.RBSteady</a></li><li><a class="tocitem" href="../rbtransient/">ROM.RBTransient</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Usage - steady problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage - steady problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nichomueller/ROM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nichomueller/ROM.jl/blob/main/docs/src/steady.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-steady-problem"><a class="docs-heading-anchor" href="#Usage-steady-problem">Usage - steady problem</a><a id="Usage-steady-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-steady-problem" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>ROM is a registered package. You can install it by running:</p><pre><code class="language-julia hljs"># Use ] to enter the Pkg REPL mode
pkg&gt; add ROM</code></pre><h2 id="Load-package"><a class="docs-heading-anchor" href="#Load-package">Load package</a><a id="Load-package-1"></a><a class="docs-heading-anchor-permalink" href="#Load-package" title="Permalink"></a></h2><p>Load the package normally with</p><pre><code class="language-julia hljs">using ROM</code></pre><h2 id="Workflow"><a class="docs-heading-anchor" href="#Workflow">Workflow</a><a id="Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow" title="Permalink"></a></h2><p>The workflow of the package is analogous to that of <a href="https://github.com/gridap/Gridap.jl">Gridap</a>, a library for the grid-based approximation of PDEs. Comprehensive Gridap tutorials can be found <a href="https://gridap.github.io/Tutorials/stable">here</a>. We load Gridap with </p><pre><code class="language-julia hljs">using Gridap</code></pre><h2 id="Manufactured-solution"><a class="docs-heading-anchor" href="#Manufactured-solution">Manufactured solution</a><a id="Manufactured-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Manufactured-solution" title="Permalink"></a></h2><p>In this example we solve with a reduced order model a parameter dependent Poisson equation </p><pre><code class="language-julia hljs">-ν*Δu  = f in Ω
ν*∇u⋅n = h in Γ</code></pre><p>where <code>Ω</code> is a sufficiently regular spatial domain, <code>ν</code> is a (positive) conductivity coefficient, <code>u</code> is the problem&#39;s unknown, <code>f</code> is a forcing term, and <code>h</code> a Neumann datum defined on the Neumann boundary <code>Γ</code>. In this problem, we consider <code>Ω = [0,1]^2</code> and <code>Γ</code> to be the right leg of the square. We consider the problem given by the following manufactured solution </p><pre><code class="language-julia hljs">ν(μ) = exp(-sum(μ))
h(μ) = 1

u(x,μ) = μ⋅x 
f(x,μ) = -ν(μ)*Δ(u(x,μ))</code></pre><p>Next, we parameterize <code>u</code> and <code>f</code> exclusively by <code>μ</code> in the following manner</p><pre><code class="language-julia hljs">uₚ(μ) = ParamFunction(x-&gt;u(x,μ),μ)
fₚ(μ) = ParamFunction(x-&gt;f(x,μ),μ)</code></pre><p>A ParamFunction is a function that can be evaluated efficiently for any number of desired parameters. In a steady setting, it takes as argument a function (<code>u</code> and <code>f</code> in the cases above) and a parameter variable. In a transient setting, an additional time variable must be included. </p><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>Define the geometry of the problem using </p><pre><code class="language-julia hljs">Ω = (0,1,0,1)
partition = (10,10)
Ωₕ = CartesianDiscreteModel(Ω,partition)</code></pre><h2 id="FE-spaces"><a class="docs-heading-anchor" href="#FE-spaces">FE spaces</a><a id="FE-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#FE-spaces" title="Permalink"></a></h2><p>Once the discrete geometry is introduced, we define a tuple of trial, test spaces <code>(U,V)</code> as</p><pre><code class="language-julia hljs">order = 1
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(Ωₕ,reffe;dirichlet_tags=[1,3,5,6,7])
U = TrialParamFESpace(V,uₚ)</code></pre><p>A <code>TrialParamFESpace</code> extends a traditional <code>TrialFESpace</code> in Gridap, as it allows to provide a <code>μ</code>-dependent Dirichlet datum. </p><h2 id="Space-of-parameters"><a class="docs-heading-anchor" href="#Space-of-parameters">Space of parameters</a><a id="Space-of-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Space-of-parameters" title="Permalink"></a></h2><p>We define a space of parameters, in this case <code>[1,10]^2</code>:</p><pre><code class="language-julia hljs">D = ParamSpace((1,10,1,10))</code></pre><p>A parameter, in our case a 2-dimensional vector, is a single realization from <code>D</code>. By default, a parameter is sampled according to a <a href="https://en.wikipedia.org/wiki/Halton_sequence">Halton</a> sequence. Other sampling methods include a uniform distribution, provided we define the space <code>D</code> as </p><pre><code class="language-julia hljs">D = ParamSpace((1,10,1,10),UniformSampling())</code></pre><p>or a normal distribution, analogously defining <code>D</code> as </p><pre><code class="language-julia hljs">ParamSpace((1,10,1,10),NormalSampling())</code></pre><p>A single parameter is sampled from <code>D</code> by calling</p><pre><code class="language-julia hljs">μ = realization(D) </code></pre><p>whereas a collection of 10 realizations can be obtained by running</p><pre><code class="language-julia hljs">μ10 = realization(D;nparams=10)</code></pre><h2 id="Numerical-integration"><a class="docs-heading-anchor" href="#Numerical-integration">Numerical integration</a><a id="Numerical-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-integration" title="Permalink"></a></h2><p>Before introducing the weak formulation of the problem, we define the quantities needed for the numerical integration </p><pre><code class="language-julia hljs">degree = 2*order
τₕ = Triangulation(Ωₕ)
Γₕ = BoundaryTriangulation(Ω;tags=[2,4,8])
dΩₕ = Measure(τₕ,degree)
dΓₕ = Measure(Γₕ,degree)</code></pre><p>The physical entities corresponding to the tags provided when defining <code>Γₕ</code> are: the bottom right vertex (2), the top right vertex (4) and the interior of the right edge (8).</p><h2 id="Weak-formulation"><a class="docs-heading-anchor" href="#Weak-formulation">Weak formulation</a><a id="Weak-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-formulation" title="Permalink"></a></h2><p>Multiplying the Poisson equation by a test function <code>v ∈ V</code> and integrating by parts yields the weak formulation of the problem, whose left- and right-hand (LHS &amp; RHS) side are</p><pre><code class="language-julia hljs">a(μ,u,v,dΩₕ) = ∫(ν(μ)*∇(v)⋅∇(u))dΩₕ 
l(μ,v,dΩₕ,dΓₕ) = ∫(fₚ(μ)*v)dΩₕ + ∫(hₚ(μ)*v)dΓₕ</code></pre><p>Note that, in contrast to a traditional Gridap code, the measures involved in the forms are passed as arguments to the forms themselves. This is necessary in order to correctly run the subsequent steps of our algorithm.</p><h2 id="Parametric-FE-problem"><a class="docs-heading-anchor" href="#Parametric-FE-problem">Parametric FE problem</a><a id="Parametric-FE-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-FE-problem" title="Permalink"></a></h2><p>At this point, we can build a FE operator representing the entire problem we aim to solve. </p><pre><code class="language-julia hljs">τₕ_l = (Ωₕ,Γₕ)
τₕ_a = (Ωₕ,)
domains = FEDomains(τₕ_l,τₕ_a)
feop = ParamLinearFEOperator(l,a,D,U,V,domains)</code></pre><p>The structure <code>FEDomains</code> collects the triangulations relative to the LHS &amp; RHS. With respect to a traditional FE operator in Gridap, a <code>ParamLinearFEOperator</code> provides the aforementioned <code>FEDomains</code> for the LHS &amp; RHS, as well as the parametric domain <code>D</code>.</p><h2 id="FE-solver"><a class="docs-heading-anchor" href="#FE-solver">FE solver</a><a id="FE-solver-1"></a><a class="docs-heading-anchor-permalink" href="#FE-solver" title="Permalink"></a></h2><p>We define the FE solver for our Poisson problem: </p><pre><code class="language-julia hljs">ls = LUSolver()
solver = LinearFESolver(ls)</code></pre><h2 id="RB-solver"><a class="docs-heading-anchor" href="#RB-solver">RB solver</a><a id="RB-solver-1"></a><a class="docs-heading-anchor-permalink" href="#RB-solver" title="Permalink"></a></h2><p>Finally, we are ready to begin the ROM part. The first part consists in defining the problem&#39;s <code>RBSolver</code>, i.e. the reduced counterpart of a FE solver:</p><pre><code class="language-julia hljs">tol = 1e-4
inner_prod(u,v) = ∫(∇(v)⋅∇(u))dΩₕ

reduction_sol = PODReduction(tol,inner_prod;nparams=20)
reduction_l = MDEIMReduction(tol;nparams=10)
reduction_a = MDEIMReduction(tol;nparams=10)
rbsolver = RBSolver(solver,reduction_sol,reduction_l,reduction_a)</code></pre><p>A <code>RBSolver</code> contains the following information: </p><ul><li><p>The FE solver </p></li><li><p>The reduction strategy for the solution. This information is used to build a projection map representing a low-dimensional approximation subspace (i.e. a trial space) for our differential problem. In the case above, we use a truncated POD with tolerance <code>tol</code> on a set of 20 snapshots. The output is orthogonal with respect to the form <code>inner_prod</code>, i.e. the <code>H^1_0</code> product. Other reduction strategies include fixing the rank of the truncation</p></li></ul><pre><code class="language-julia hljs">rank = 5
reduction_sol = PODReduction(rank,inner_prod;nparams=20)</code></pre><p>and using randomized POD algorithms</p><pre><code class="language-julia hljs">reduction_sol = PODReduction(tol,inner_prod;nparams=20,sketch=:sprn)</code></pre><p>A comprehensive documentation on randomized POD algorithms can be found <a href="https://github.com/JuliaLinearAlgebra/LowRankApprox.jl">here</a>.</p><ul><li><p>The hyper-reduction strategy for the RHS. This information is used to build a projection map representing a low-dimensional subspace for the RHS, equipped with a reduced integration domain obtained via MDEIM, i.e. the matrix-based empirical interpolation method. A total of 10 residual snapshots is used to compute the output.</p></li><li><p>Similarly, the hyper-reduction strategy for the LHS.</p></li></ul><h2 id="Offline-phase"><a class="docs-heading-anchor" href="#Offline-phase">Offline phase</a><a id="Offline-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Offline-phase" title="Permalink"></a></h2><p>The offline phase is the part of the code where the projection maps for the solution, LHS &amp; RHS are computed. This phase is quite expensive to run, but on the upside it can just be run once, provided the outputs are saved to file. For this purpose, we load the well-known packages <a href="https://juliadynamics.github.io/DrWatson.jl/stable/">DrWatson</a> and <a href="https://docs.julialang.org/en/v1/stdlib/Serialization/">Serialization</a></p><pre><code class="language-julia hljs">using DrWatson 
using Serialization</code></pre><p>and define a saving directory for our example</p><pre><code class="language-julia hljs">dir = datadir(&quot;poisson&quot;)
create_dir(dir) </code></pre><p>Next, we try loading the offline quantities; if the load fails, we must run the offline phase </p><pre><code class="language-julia hljs">try # try loading offline quantities
    rbop = load_operator(dir,feop)
catch # offline phase
    rbop = reduced_operator(rbsolver,feop)
    save(dir,rbop)
end</code></pre><p>The load might fail, for e.g., if </p><ul><li><p>It is the first time running the code</p></li><li><p>A different directory was used to save the offline structures in previous runs </p></li><li><p>For developers, if the definition of one of the loaded types has changed since it was saved to file </p></li></ul><p>The offline structures are completely contained in the variable <code>rbop</code>, which is the reduced version of the FE operator <code>feop</code>. To understand better the meaning of this variable, we report the content of the function <code>reduced_operator</code>:</p><pre><code class="language-julia hljs"># compute the solution snapshots 
fesnaps, = solution_snapshots(rbsolver,feop) 
# compute the reduced trial and test spaces 
Û,V̂ = reduced_spaces(rbsolver,feop,fesnaps)
# compute the hyper-reduction for LHS &amp; RHS
op = get_algebraic_operator(feop)
â,l̂ = reduced_weak_form(rbsolver,op,Û,V̂,fesnaps)

# fetch the reduced FEDomains
τₕ_l̂,τₕ_â = get_domains(l̂),get_domains(â)
# replace the original FEDomains with the new ones  
op′ = change_domains(op,τₕ_l̂,τₕ_â)
# definition of reduced operator 
rbop = GenericRBOperator(op′,Û,V̂,â,l̂)</code></pre><h2 id="Online-phase"><a class="docs-heading-anchor" href="#Online-phase">Online phase</a><a id="Online-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Online-phase" title="Permalink"></a></h2><p>This step consists in computing the ROM approximation for any desired parameter. We consider, for e.g., 10 parameters distributed uniformly on <code>D</code></p><pre><code class="language-julia hljs">μon = realization(D;nparams=10,rand=true)</code></pre><p>and we solve the reduced problem </p><pre><code class="language-julia hljs">x̂on,rbstats = solve(rbsolver,rbop,μon)</code></pre><h2 id="Post-processing"><a class="docs-heading-anchor" href="#Post-processing">Post processing</a><a id="Post-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing" title="Permalink"></a></h2><p>In order to test the quality of the approximation <code>x̂on</code>, we can run the following post-processing code </p><pre><code class="language-julia hljs">xon,festats = solve(rbsolver,feop,μon)
perf = eval_performance(rbsolver,feop,rbop,xon,x̂on,festats,rbstats,μon)
println(perf)</code></pre><p>In other words, we first compute the HF solution <code>xon</code> in the online parameters <code>μon</code>, and then we run the performance tester, which in particular returns</p><ul><li><p>The relative error ||xon - x̂on|| / ||xon||, averaged on the 10 parameters in <code>μon</code>. The norm is the one specified by <code>inner_prod</code>, so in our case the <code>H^1_0</code> product.</p></li><li><p>The speedup in terms of time and memory achieved with respect to the HF simulations. This is done by comparing the variables <code>rbstats</code> and <code>festats</code>, which contain the time (in seconds) and memory allocations (in Gb) of the two algorithms.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../transient/">Usage - transient problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 16 February 2025 23:00">Sunday 16 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
